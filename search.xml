<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>15. 3Sum</title>
      <link href="/2020/02/07/0015/"/>
      <url>/2020/02/07/0015/</url>
      
        <content type="html"><![CDATA[<h1 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/07/NqMmn6TCGHwb2iA.png" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>1. 排序</strong>（$O(NlogN)$）<br>为什么要排序呢？我想是不是这样：</p><ul><li>排序后相同的数会挨在一起，所以方便接下来的操作来避免重复；</li><li>右边的数比左边的大，方便比较。</li></ul><p><strong>2. 遍历</strong>（$O(N^2)$）<br>我们定义当前下标 <code>k</code>，<code>i, j</code> 分别位于 <code>k + 1, len(nums) - 1</code>的位置。若 <code>k = 1</code>，如下图所示：</p><p><img src="https://pic.leetcode-cn.com/26f5fa65fe52bf8b7c2397f2a9ce4efe0fbb29b939ad411c938e87b06022a6b9-file_1581062450524" alt="1.png"></p><p>从左到右遍历，对于每个 <code>k</code> 值：</p><ul><li>如果三数之和大于 <code>0</code>，<code>j</code> 左移会使得和减小，甚至等于 <code>0</code>，故 <code>j</code> 左移；</li><li>如果三数之和小于 <code>0</code>，<code>i</code> 右移会使得和增大，甚至等于 <code>0</code>，故 <code>i</code> 右移；</li><li>如果三数之和等于 <code>0</code>，将 <code>[nums[i],nums[j],nums[k]]</code> 加入到结果中，<code>i</code> 右移，<code>j</code> 左移，寻找下一组可能结果。</li></ul><p>移动的过程中，如果碰到的数与前一个数相同，我们跳过本次循环，避免结果重复！</p><p><img src="https://i.loli.net/2020/02/07/sC1pl5etox6B9fM.gif" alt="fig 1"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">break</span> <span class="token comment" spellcheck="true"># k后面的数肯定大于零，跳出循环</span>            <span class="token keyword">if</span> k <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">continue</span>             i<span class="token punctuation">,</span> j <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">while</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    i <span class="token operator">+=</span> <span class="token number">1</span>                    j <span class="token operator">-=</span> <span class="token number">1</span>                    <span class="token keyword">while</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">and</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>i <span class="token operator">+=</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># 相同的数跳过</span>                    <span class="token keyword">while</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">and</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>j <span class="token operator">-=</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># 相同的数跳过</span>                <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                    i <span class="token operator">+=</span> <span class="token number">1</span>                    <span class="token keyword">while</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">and</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>i <span class="token operator">+=</span> <span class="token number">1</span>                 <span class="token keyword">else</span><span class="token punctuation">:</span>                    j <span class="token operator">-=</span> <span class="token number">1</span>                    <span class="token keyword">while</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">and</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>j <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(N^2)$。</li><li>空间复杂度：$O(1)$。<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3></li></ul><p>有比时间复杂度为 $O(n^2)$ 更低的算法吗？事实上是有的，比如 <a href="https://en.wikipedia.org/wiki/3SUM" target="_blank" rel="noopener">维基百科</a> 中的 $O(n^2/(log n/ log log n)^2/3)$ 等。但是对于刷题人来讲，掌握 $O(n^2)$ 的解法我觉得已经足够。😄</p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12. Integer to Roman</title>
      <link href="/2020/02/07/0012/"/>
      <url>/2020/02/07/0012/</url>
      
        <content type="html"><![CDATA[<h1 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="12. Integer to Roman"></a>12. Integer to Roman</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/07/2uUAOKCNxHLEp9n.png" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们每次尽量使用最大的数来表示，这个方法符合贪心法则。比如对于 1994 这个数，如果我们每次尽量用最大的数来表示，依次选 1000，900，90，4，会得到正确结果 <code>MCMXCIV</code>。</p><p>所以，我们将哈希表按照从大到小的顺序排列，然后遍历哈希表，直到表示完整个输入。</p><p><img src="https://i.loli.net/2020/02/07/HWvbXJs8yGtSq6T.gif" alt="fig 1"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">intToRoman</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 使用哈希表，按照从大到小顺序排列</span>        hashmap <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1000</span><span class="token punctuation">:</span><span class="token string">'M'</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">:</span><span class="token string">'CM'</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">:</span><span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">:</span><span class="token string">'CD'</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">:</span><span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">:</span><span class="token string">'XC'</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">:</span><span class="token string">'L'</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">:</span><span class="token string">'XL'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">:</span><span class="token string">'X'</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">:</span><span class="token string">'IX'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">:</span><span class="token string">'V'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">:</span><span class="token string">'IV'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token string">'I'</span><span class="token punctuation">}</span>        res <span class="token operator">=</span> <span class="token string">''</span>        <span class="token keyword">for</span> key <span class="token keyword">in</span> hashmap<span class="token punctuation">:</span>            <span class="token keyword">if</span> num <span class="token operator">//</span> key <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                count <span class="token operator">=</span> num <span class="token operator">//</span> key  <span class="token comment" spellcheck="true"># 比如输入4000，count 为 4</span>                res <span class="token operator">+=</span> hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">*</span> count                 num <span class="token operator">%=</span> key        <span class="token keyword">return</span> res</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(1)$。最坏条件下，循环的次数为哈希表的长度。</li><li>空间复杂度：$O(1)$。</li></ul><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13. Roman to Integer</title>
      <link href="/2020/02/07/0013/"/>
      <url>/2020/02/07/0013/</url>
      
        <content type="html"><![CDATA[<h1 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a>13. Roman to Integer</h1><h3 id="题目描述（难度：简单）"><a href="#题目描述（难度：简单）" class="headerlink" title="题目描述（难度：简单）"></a>题目描述（难度：简单）</h3><p><img src="https://i.loli.net/2020/02/07/h29b5oQBwxz1GRZ.png" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过观察我们发现，<strong>只有在遇到特殊情况时，两个字符中左边的字符小于右边的字符，且等于右边的字符代表的数减左边字符代表的数</strong>。 比如 <code>CM</code> 等于 $1000 - 100$，<code>XC</code> 等于 $100 - 10$…</p><p>因此，我们将 <code>字符：数值</code> 存在 <code>Roman2Int</code> 的哈希表中。然后从左到右遍历每个字符，如果 <code>s[i] &lt; s[i+1]</code>，就将结果减去 <code>s[i]</code> 代表的数字；否则，将结果加上 <code>s[i]</code> 代表的数字。</p><p><img src="https://i.loli.net/2020/02/07/nOFuzgEqVbNJ6iL.gif" alt="fig 1"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">romanToInt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        Roman2Int <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'I'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'V'</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">'X'</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'L'</span><span class="token punctuation">:</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token string">'C'</span><span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">'D'</span><span class="token punctuation">:</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token string">'M'</span><span class="token punctuation">:</span><span class="token number">1000</span><span class="token punctuation">}</span>        Int <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> Roman2Int<span class="token punctuation">[</span>s<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> Roman2Int<span class="token punctuation">[</span>s<span class="token punctuation">[</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                Int <span class="token operator">-=</span> Roman2Int<span class="token punctuation">[</span>s<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                Int <span class="token operator">+=</span> Roman2Int<span class="token punctuation">[</span>s<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> Int <span class="token operator">+</span> Roman2Int<span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(N)$。遍历了一遍数组。</li><li>空间复杂度：$O(1)$。使用了 <code>Int</code>。</li></ul><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42. Trapping Rain Water</title>
      <link href="/2020/02/06/0042/"/>
      <url>/2020/02/06/0042/</url>
      
        <content type="html"><![CDATA[<h1 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42. Trapping Rain Water"></a>42. Trapping Rain Water</h1><h3 id="题目描述（难度：困难）"><a href="#题目描述（难度：困难）" class="headerlink" title="题目描述（难度：困难）"></a>题目描述（难度：困难）</h3><p><img src="https://i.loli.net/2020/02/05/RpYfBHiJtQVjkcT.png" alt=""></p><h3 id="方法一：暴力"><a href="#方法一：暴力" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h3><p>一开始拿到题目之后可能会有些手足无措，我们从最原始的暴力解法开始思考，对于每个下标 i，我们计算它上方可以接多少雨水，然后将所有下标上的雨水加起来即可。</p><p><img src="https://i.loli.net/2020/02/06/Kfp3ARoSmc98Zud.png" alt="fig 1"></p><p>具体来说，如图我们假设输入为 <code>[0,1,0,2]</code>，凭感觉，我们得到接完雨水后的结果如右图。可以看到，只有下标 2 的上方可以接到雨水，其他地方的水会向两边“流掉”，所以无法接到水。</p><p>为什么是这样呢？首先看下标 1 ，它左边最高的柱子是下标 0 ，右边最高的柱子是下标 3 ，因为这两个柱子的较小值比下标 1 要低，所以下标 1 的上方没有水。相反，我们看下标 2，它左边最高的柱子是下标 1 ，右边最高的柱子是下标 3 ，这两个柱子较矮的是下标 1 ，它比下标 2 本身要高，所以下标 2 可以接到水，接的水就是高度差。</p><p>因此，我们遍历每个下标，寻找它左边和右边最高的柱子，判断是否可以接到水，将可接水的结果累加即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>Python3 代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">trap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        ans <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            max_left<span class="token punctuation">,</span> max_right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>            <span class="token comment" spellcheck="true"># 寻找 max_left</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                max_left <span class="token operator">=</span> max<span class="token punctuation">(</span>max_left<span class="token punctuation">,</span>height<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 寻找 max_right</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span>len<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                max_right <span class="token operator">=</span> max<span class="token punctuation">(</span>max_right<span class="token punctuation">,</span>height<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> min<span class="token punctuation">(</span>max_left<span class="token punctuation">,</span>max_right<span class="token punctuation">)</span> <span class="token operator">></span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                ans <span class="token operator">+=</span> min<span class="token punctuation">(</span>max_left<span class="token punctuation">,</span>max_right<span class="token punctuation">)</span> <span class="token operator">-</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> ans</code></pre><p>C++ 代码如下：</p><pre class=" language-C++"><code class="language-C++">class Solution {public:    int trap(vector<int>& height) {        int ans = 0;        int n = height.size();        int maxleft;        int maxright;        for (int i = 0;i < n;i++){            maxleft = maxright = 0;            for (int j = 0;j < i;j++){                maxleft = max(maxleft,height[j]);            }            for (int k = i;k<n;k++){                maxright = max(maxright,height[k]);            }            if (min(maxleft,maxright) > height[i]){                ans += min(maxleft,maxright) - height[i];            }        }        return ans;    }};</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N^2)。最坏情况下，我们对于每个下标，都要向左和向右遍历直到两端，复杂度是 N 的平方。</li><li>空间复杂度：O(1)。使用了有限的 <code>n</code>, <code>ans</code>, <code>maxleft</code>, <code>maxright</code>。</li></ul><h3 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p>我们发现在寻找每个下标的左边和右边最高的柱子时，会对柱子进行反复搜索导致复杂度降低，假如我们使用两个数组 <code>maxleft</code> 和 <code>maxright</code>，<code>maxleft[i]</code> 表示下标 <code>i</code> 左边最高柱子的高度，<code>maxright[i]</code> 表示下标 <code>i</code> 右边最高柱子的高度，很明显，我们只需要一趟遍历就可以得到结果。这样由于避免了重复计算，时间复杂度会降低到 O(N)。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>Python3 代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">trap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 边界条件</span>        <span class="token keyword">if</span> <span class="token operator">not</span> height<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>height<span class="token punctuation">)</span>        maxleft <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        maxright <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        ans <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 初始化</span>        maxleft<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        maxright<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 设置备忘录，分别存储左边和右边最高的柱子高度</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            maxleft<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>maxleft<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            maxright<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>height<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>maxright<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 一趟遍历，比较每个位置可以存储多少水</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> min<span class="token punctuation">(</span>maxleft<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>maxright<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                ans <span class="token operator">+=</span> min<span class="token punctuation">(</span>maxleft<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>maxright<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> ans</code></pre><p>C++ 代码：</p><pre class=" language-C++"><code class="language-C++">class Solution {public:    int trap(vector<int>& height) {        if (height.size() == 0){            return 0;        }        int n = height.size();        vector<int> maxleft (n);        vector<int> maxright (n);        int ans = 0;        maxleft[0] = height[0];        maxright[n-1] = height[n-1];        for (int i=1;i<n;i++){            maxleft[i] = max(height[i], maxleft[i-1]);        }        for (int j=n-2;j>-1;j--){            maxright[j] = max(height[j],maxright[j+1]);        }        for (int k=0;k<n;k++){            if (min(maxleft[k],maxright[k]) > height[k]){                ans += min(maxleft[k],maxright[k]) - height[k];            }         }        return ans;    }};</code></pre><p>由于使用了数组，我们的空间复杂度会增加到 O(N),如何能把空间复杂度也降低呢？我们可以使用双指针法。</p><h3 id="方法三：双指针法"><a href="#方法三：双指针法" class="headerlink" title="方法三：双指针法"></a>方法三：双指针法</h3><p>双指针法就是将上边的一个下标 <code>i</code>，变为两个下标 <code>left</code>，<code>right</code>，分别位于输入数组的两端。向中间移动时，边移动边计算。</p><p>除此之外，我们使用 <code>maxleft</code> 作为 <code>0...left</code> 的最大值，<code>maxright</code> 作为 <code>right...结尾</code> 的最大值。<br><img src="https://i.loli.net/2020/02/06/vghCOkoyV7qxlw3.gif" alt="fig 2"></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>Python 代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">trap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 边界条件</span>        <span class="token keyword">if</span> <span class="token operator">not</span> height<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>height<span class="token punctuation">)</span>        left<span class="token punctuation">,</span>right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># 分别位于输入数组的两端</span>        maxleft<span class="token punctuation">,</span>maxright <span class="token operator">=</span> height<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        ans <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;=</span> right<span class="token punctuation">:</span>            maxleft <span class="token operator">=</span> max<span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>maxleft<span class="token punctuation">)</span>            maxright <span class="token operator">=</span> max<span class="token punctuation">(</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span>maxright<span class="token punctuation">)</span>            <span class="token keyword">if</span> maxleft <span class="token operator">&lt;</span> maxright<span class="token punctuation">:</span>                ans <span class="token operator">+=</span> maxleft <span class="token operator">-</span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                left <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                ans <span class="token operator">+=</span> maxright <span class="token operator">-</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span>                right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> ans</code></pre><p>C++ 代码：</p><pre class=" language-C++"><code class="language-C++">class Solution {public:    int trap(vector<int>& height) {        if(height.size() == 0){            return 0;        }        int n = height.size();        int left = 0;        int right = n - 1;        int maxleft = height[0];        int maxright = height[n-1];        int ans = 0;        while (left <= right){            maxleft = max(height[left],maxleft);            maxright = max(height[right],maxright);            if(maxleft < maxright){                ans += maxleft - height[left];                left++;            }            else{                ans += maxright - height[right];                right--;            }        }        return ans;    }};</code></pre><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N)。遍历了一遍数组。</li><li>空间复杂度：O(1)。使用了有限的 <code>left</code>, <code>right</code>, <code>ans</code>, <code>maxleft</code>, <code>maxright</code>。</li></ul><p>如有疑问，欢迎批评指正~</p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. Container With Most Water</title>
      <link href="/2020/02/05/0011/"/>
      <url>/2020/02/05/0011/</url>
      
        <content type="html"><![CDATA[<h1 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/05/f75Z8zFqr96ipAw.png" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><a href="https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode/" target="_blank" rel="noopener">可以参考官方题解的动图</a>，思路很简单，设置两个指针 <code>start</code> 和 <code>end</code> 分别位于容器两端，当 <code>start &lt; end</code> 时，每次将高度较矮的指针向内移动，同时更新最大面积。（这个的证明可以用反证法，官方题解可以找到）通俗来讲，因为每次向内移动时，距离就减小，只有移动高度较矮的那个，才有机会碰到高度更高的使得面积增大。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxArea</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        ans <span class="token operator">=</span> float<span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>        start<span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>height<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> start <span class="token operator">&lt;</span> end<span class="token punctuation">:</span>            ans <span class="token operator">=</span> max<span class="token punctuation">(</span>ans<span class="token punctuation">,</span>min<span class="token punctuation">(</span>height<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> height<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> height<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">:</span>                start <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                end <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> ans</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(1)</li></ul><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>有很多题如果只想到了 O(N^2) 的解法往往是不够的，比如这道题利用双指针可以优化到 O(N)。这道题二刷的时候做得确实比开始时候要轻松一些~加油！</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10. Regular Expression Matching</title>
      <link href="/2020/02/05/0010/"/>
      <url>/2020/02/05/0010/</url>
      
        <content type="html"><![CDATA[<h1 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a>10. Regular Expression Matching</h1><h3 id="题目描述（难度：困难）"><a href="#题目描述（难度：困难）" class="headerlink" title="题目描述（难度：困难）"></a>题目描述（难度：困难）</h3><p><img src="https://i.loli.net/2020/02/05/OHLFRpZn8ybgW73.png" alt=""></p><h3 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h3><p>首先，我们考虑只有’.’的情况。这种情况会很简单：我们只需要从左到右依次判断 <code>s[i]</code> 和 <code>p[i]</code> 是否匹配。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>s<span class="token punctuation">:</span>str<span class="token punctuation">,</span> p<span class="token punctuation">:</span>str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token operator">not</span> p<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">not</span> s <span class="token comment" spellcheck="true"># 边界条件</span>    first_match <span class="token operator">=</span> s <span class="token operator">and</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">in</span> <span class="token punctuation">{</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'.'</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true"># 比较第一个字符是否匹配</span>    <span class="token keyword">return</span> first_match <span class="token operator">and</span> self<span class="token punctuation">.</span>isMatch<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>如果有星号，它会出现在 <code>p[1]</code> 的位置，这时有两种情况：</p><ul><li>星号代表匹配 0 个前面的元素。如 <code>'##'</code> 和 <code>a*##</code>，这时我们直接忽略 p 的 <code>a*</code>，比较 <code>##</code> 和 <code>##</code>；</li><li>星号代表匹配一个或多个前面的元素。如 <code>aaab</code> 和 <code>a*b</code>，这时我们将忽略 s 的第一个元素，比较 <code>aab</code> 和 <code>a*b</code>。</li></ul><p>以上任一情况忽略掉元素进行比较时，剩下的如果匹配，我们认为 s 和 p 是匹配的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> p<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> p<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">not</span> s        <span class="token comment" spellcheck="true"># 第一个字母是否匹配</span>        first_match <span class="token operator">=</span> s <span class="token operator">and</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">in</span> <span class="token punctuation">{</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'.'</span><span class="token punctuation">}</span>        <span class="token comment" spellcheck="true"># 如果 p 第二个字母是 *</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span> <span class="token operator">and</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"*"</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>isMatch<span class="token punctuation">(</span>s<span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> \            first_match <span class="token operator">and</span> self<span class="token punctuation">.</span>isMatch<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> first_match <span class="token operator">and</span> self<span class="token punctuation">.</span>isMatch<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h3 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>很容易想到，<code>dp[i][j]</code> 表示的状态是 s 的前 i 项和 p 的前 j 项是否匹配。</p><h4 id="转移方程"><a href="#转移方程" class="headerlink" title="转移方程"></a>转移方程</h4><p>现在如果已知了 <code>dp[i-1][j-1]</code> 的状态，我们该如何确定 <code>dp[i][j]</code> 的状态呢？我们可以分三种情况讨论，其中，前两种情况考虑了所有能匹配的情况，剩下的就是不能匹配的情况了：</p><ul><li><p><code>s[i] == p[j] or p[j] == '.'</code>：比如 ab<strong>b</strong> 和 ab<strong>b</strong>，或者 ab<strong>b</strong> 和 ab. ，很容易得到 <code>dp[i][j] = dp[i-1][j-1] = True</code>。因为 ab 和 ab 是匹配的，如果后面分别加一个 b，或者 s 加一个 b 而 p 加一个 . ，仍然是匹配的。</p></li><li><p><code>p[j] == '*'</code>：当 <code>p[j]</code> 为星号时，由于星号与前面的字符相关，因此我们比较星号前面的字符 <code>p[j-1]</code> 和 <code>s[i]</code> 的关系。根据星号前面的字符与 <code>s[i]</code> 是否相等，又可分为以下两种情况：</p><ul><li><code>p[j-1] != s[i]</code>：如果星号前一个字符匹配不上，星号匹配了 0 次，应忽略这两个字符，看 <code>p[j-2]</code> 和 <code>s[i]</code> 是否匹配。 这时 <code>dp[i][j] = dp[i][j-2]</code>。</li><li><code>p[j-1] == s[i] or p[j-1] == '.'</code>:星号前面的字符可以与 <code>s[i]</code> 匹配，这种情况下，星号可能匹配了前面的字符的 0 个，也可能匹配了前面字符的多个，当匹配 0 个时，如 a<strong>b</strong> 和 ab<strong>b*</strong>，或者 a<strong>b</strong> 和 ab.* ，这时我们需要去掉 p 中的 <code>b*</code> 或 <code>.*</code> 后进行比较，即 <code>dp[i][j] = dp[i][j-2]</code>；当匹配多个时，如 abb<strong>b</strong> 和 a<strong>b*</strong>，或者 abb<strong>b</strong> 和 a.*，我们需要将 <code>s[i]</code> 前面的与 p 重新比较，即 <code>dp[i][j] = dp[i-1][j]</code></li></ul></li><li><p>其他情况：以上两种情况把能匹配的都考虑全面了，所以其他情况为不匹配，即 <code>dp[i][j] = False</code></p></li></ul><h4 id="将以上进行归纳得到状态转移方程"><a href="#将以上进行归纳得到状态转移方程" class="headerlink" title="将以上进行归纳得到状态转移方程"></a>将以上进行归纳得到状态转移方程</h4><p><img src="https://i.loli.net/2020/02/05/37IrNXSBDTR2nd1.png" alt="fig 1"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> p<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 边界条件，考虑 s 或 p 分别为空的情况</span>        <span class="token keyword">if</span> <span class="token operator">not</span> p<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">not</span> s        <span class="token keyword">if</span> <span class="token operator">not</span> s <span class="token operator">and</span> len<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>        m<span class="token punctuation">,</span> n <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 初始状态</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            j <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">if</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> r <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            i <span class="token operator">=</span> r <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">for</span> c <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                j <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token number">1</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">or</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>                <span class="token keyword">elif</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">:</span>       <span class="token comment" spellcheck="true"># ‘*’前面的字符匹配s[i] 或者为'.'</span>                    <span class="token keyword">if</span> p<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">or</span> p<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">or</span> dp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                       <span class="token comment" spellcheck="true"># ‘*’匹配了0次前面的字符</span>                        dp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span>                 <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span></code></pre><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>递归的方法思路比较简单，动态规划中处理星号和点的时候，需要将细节考虑清楚，这样写代码的时候就容易了~加油！</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> Python3 </tag>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>55. Jump Game</title>
      <link href="/2020/02/04/0055/"/>
      <url>/2020/02/04/0055/</url>
      
        <content type="html"><![CDATA[<h1 id="1344-Jump-Game-V"><a href="#1344-Jump-Game-V" class="headerlink" title="1344. Jump Game V"></a>1344. Jump Game V</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/04/cAE6rgJXDdsLm1B.png" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们设定初始值 <code>max_i</code> 为当前可跳的最远位置，遍历一遍数组，维护 <code>max_i</code>。遍历结束后，如果 <code>max_i &gt;= len(nums) - 1</code>，这时说明能够到达最后位置,返回 <code>True</code>，否则返回 <code>False</code>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>Python3</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canJump</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 初始化能到达的最远位置</span>        max_i <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> num <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> max_i <span class="token operator">>=</span> i <span class="token operator">and</span> i <span class="token operator">+</span> num <span class="token operator">></span> max_i<span class="token punctuation">:</span>                max_i <span class="token operator">=</span> i <span class="token operator">+</span> num        <span class="token keyword">return</span> max_i <span class="token operator">>=</span> i <span class="token comment" spellcheck="true"># >= 是因为可能会跳出界</span></code></pre><p>C++</p><pre class=" language-C++"><code class="language-C++">class Solution {public:    bool canJump(vector<int>& nums) {        int max_i = 0;        for(int i = 0; i<nums.size();i++){            if(max_i >= i && i + nums[i] > max_i){                max_i = i + nums[i];            }        }        return max_i >= nums.size() - 1;    }};</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N)。</li><li>空间复杂度：O(1)。</li></ul><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ul><li><a href="//0045.md">跳跃游戏 Ⅱ</a></li><li><a href="//1306.md">跳跃游戏 Ⅲ</a></li><li>跳跃游戏 Ⅳ</li><li>跳跃游戏 Ⅴ</li></ul><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>动态规划的题目比较难，我们需要吃透几个题目，慢慢去体会~加油！</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 贪心算法 </tag>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>240. Search a 2D Matrix II</title>
      <link href="/2020/02/04/0240/"/>
      <url>/2020/02/04/0240/</url>
      
        <content type="html"><![CDATA[<h1 id="240-Search-a-2D-Matrix-II"><a href="#240-Search-a-2D-Matrix-II" class="headerlink" title="240. Search a 2D Matrix II"></a>240. Search a 2D Matrix II</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/06/gVxYfNpzOJZ84jB.png" alt=""><br>解题思路<br>我们从左下角开始遍历，当该值小于 target 值时，向右搜索；大于 target 值时，向上搜索。如果找到 target 则返回 True，否则返回 False。</p><p><img src="https://i.loli.net/2020/02/06/6RJQ1LcpszHojAy.gif" alt="fig 1"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>python 代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># array 二维列表</span>    <span class="token keyword">def</span> <span class="token function">Find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> target<span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> array<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>        m<span class="token punctuation">,</span> n <span class="token operator">=</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        row<span class="token punctuation">,</span> col <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">while</span> row <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> col <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>            <span class="token keyword">if</span> array<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                col <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> array<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">:</span>                row <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span></code></pre><p>C++ 代码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> row <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>row <span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> col <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>                col <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>                row <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(m+n)。m 和 n 分别为行数和列数。最坏情况下，我们从左下角移动到右上角，经过的路径长度为。</li><li>空间复杂度：O(1)。</li></ul><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1344. Jump Game V</title>
      <link href="/2020/02/04/1344/"/>
      <url>/2020/02/04/1344/</url>
      
        <content type="html"><![CDATA[<h1 id="1344-Jump-Game-V"><a href="#1344-Jump-Game-V" class="headerlink" title="1344. Jump Game V"></a>1344. Jump Game V</h1><h3 id="题目描述（难度：困难）"><a href="#题目描述（难度：困难）" class="headerlink" title="题目描述（难度：困难）"></a>题目描述（难度：困难）</h3><p><img src="https://i.loli.net/2020/02/04/OnIFXgYorURdW6s.png" alt=""></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>我们记录每个下标 <code>i</code> 可以最多访问的下标个数，返回最大值就行了。</p><p>如何记录每个下标的最多访问个数呢？我们使用一维动态规划数组 <code>dp</code> 。<strong>dp[i] 表示下标 i 的最多可访问次数</strong>，我们按照高度从低到高的顺序遍历每个下标，<strong>在可跳范围内</strong>，我们更新 <code>dp[i]</code> 的值。状态方程为 $dp[i] = max(dp[idx] + 1, cur)$ ,建议查看 <a href="https://leetcode-cn.com/problems/jump-game-v/solution/yi-wei-dong-tai-gui-hua-tu-jie-python3-by-ml-zimin/" target="_blank" rel="noopener">原题解动图</a> 理解状态方程。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxJumps</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        L <span class="token operator">=</span> sorted<span class="token punctuation">(</span>L<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token keyword">for</span> h<span class="token punctuation">,</span> i <span class="token keyword">in</span> L<span class="token punctuation">:</span>            cur <span class="token operator">=</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 向左跳</span>            <span class="token keyword">for</span> idx <span class="token keyword">in</span> range<span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> max<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">-</span> d<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> arr<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">>=</span> h<span class="token punctuation">:</span>                    <span class="token keyword">break</span>                cur <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>cur<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 向右跳</span>            <span class="token keyword">for</span> idx <span class="token keyword">in</span> range<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> min<span class="token punctuation">(</span>n<span class="token punctuation">,</span> i <span class="token operator">+</span> d <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> arr<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">>=</span> h<span class="token punctuation">:</span>                    <span class="token keyword">break</span>                cur <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> cur<span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cur        <span class="token keyword">return</span><span class="token punctuation">(</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(NlogN)。我们遍历了一遍数组，复杂度为 O(N)，再最坏条件下，d = N，对于每个下标的时间复杂度为 O(logN)，因此时间复杂度为 O(NlogN)。</li><li>空间复杂度：O(N)。使用了 <code>L</code> 和 <code>dp</code>。</li></ul><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ul><li><a href="//0045.md">跳跃游戏 Ⅱ</a></li><li><a href="//1306.md">跳跃游戏 Ⅲ</a></li><li>跳跃游戏 Ⅳ</li><li>跳跃游戏 Ⅴ</li></ul><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>动态规划的题目比较难，我们需要吃透几个题目，慢慢去体会~加油！</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1306. Jump Game III</title>
      <link href="/2020/02/04/1306/"/>
      <url>/2020/02/04/1306/</url>
      
        <content type="html"><![CDATA[<h1 id="1306-Jump-Game-III"><a href="#1306-Jump-Game-III" class="headerlink" title="1306. Jump Game III"></a>1306. Jump Game III</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/04/JmLYcaMZ8dS29hb.png" alt=""></p><h3 id="解题思路：BFS"><a href="#解题思路：BFS" class="headerlink" title="解题思路：BFS"></a>解题思路：BFS</h3><p>当我们每次位于 i 位置时，我们会困惑于该跳到哪个位置是最优的。因此可采取以下贪心法则：如果跳到位置 j 时下一次可以跳得最远，那么我们就选取该位置。如下图所示，当我们位于初始位置 2（i = 0） 时，可以跳到黄色位置，由于 3 比 1 跳得远，因此我们选择跳到 3 的位置。</p><p><img src="https://i.loli.net/2020/02/04/m1dBWsPco8wUCzD.gif" alt="fig 1"></p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><pre><code>class Solution:    def canReach(self, arr: List[int], start: int) -&gt; bool:        # 边界条件        if arr[start] == 0:            return True        n = len(arr)        used = {start} # 已被访问过的结点保存在此集合中        q = collections.deque([start])  # 初始化队列q        while q:            u = q.popleft()            for v in [u - arr[u],u + arr[u]]:                if 0 &lt;= v &lt; n and v not in used:                    if arr[v] == 0:                        return True                    used.add(v)                    q.append(v)        return False</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N)，遍历了一遍数组。</li><li>空间复杂度：O(N)，使用了集合和队列。</li></ul><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ul><li>[跳跃游戏 Ⅱ](//0045. Jump Game II.md)</li><li>跳跃游戏 Ⅲ</li><li>跳跃游戏 Ⅳ</li><li>跳跃游戏 Ⅴ</li></ul><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>代码比较简单，思路要理清~加油！</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 队列 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>45. Jump Game II</title>
      <link href="/2020/02/03/0045/"/>
      <url>/2020/02/03/0045/</url>
      
        <content type="html"><![CDATA[<h1 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a>45. Jump Game II</h1><h3 id="题目描述（难度：困难）"><a href="#题目描述（难度：困难）" class="headerlink" title="题目描述（难度：困难）"></a>题目描述（难度：困难）</h3><p><img src="https://i.loli.net/2020/02/03/fyHsrJbXAESFC8a.png" alt=""></p><h3 id="解题思路：贪心法则"><a href="#解题思路：贪心法则" class="headerlink" title="解题思路：贪心法则"></a>解题思路：贪心法则</h3><p>当我们每次位于 i 位置时，我们会困惑于该跳到哪个位置是最优的。因此可采取以下贪心法则：如果跳到位置 j 时下一次可以跳得最远，那么我们就选取该位置。如下图所示，当我们位于初始位置 2（i = 0） 时，可以跳到黄色位置，由于 3 比 1 跳得远，因此我们选择跳到 3 的位置。</p><p><img src="https://i.loli.net/2020/02/03/GeP7vgIOfTkt3jN.png" alt="fig 1"></p><p>现在我们位于位置 3 ，黄色点是可以跳到的位置，因为跳到 4 时可以跳得更远，因此我们选择跳到位置 4 。</p><p><img src="https://i.loli.net/2020/02/03/xstYGP4vLiWfqbO.png" alt="fig 2"></p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><pre><code>class Solution:    def jump(self, nums: List[int]) -&gt; int:        steps = 0        end = 0        maxposition = 0  # maxposition 为每次跳跃最优的位置        for i in range(len(nums) - 1):            maxposition = max(maxposition, nums[i] + i)            # 当我们找到了可以跳的最优位置，step + 1            if i == end:                end = maxposition                steps += 1        return steps</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N)。N 是数组的长度，我们遍历了一遍数组。</li><li>空间复杂度：O(1)。我们仅使用了 <code>steps</code>，<code>end</code>，<code>maxpositon</code> 等有限的额外空间。</li></ul><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ul><li>跳跃游戏</li><li>跳跃游戏 Ⅲ</li><li>跳跃游戏 Ⅳ</li><li>跳跃游戏 Ⅴ</li></ul><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>代码比较简单，思路要理清~加油！</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. Two Sum</title>
      <link href="/2020/01/31/0001/"/>
      <url>/2020/01/31/0001/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h1><h3 id="题目描述（难度：简单）"><a href="#题目描述（难度：简单）" class="headerlink" title="题目描述（难度：简单）"></a>题目描述（难度：简单）</h3><p><img src="https://i.loli.net/2020/02/07/drzu8OcZ9VhbKoG.png" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过迭代将元素添加到哈希表中，同时我们比较该元素的对应元素是否已经存在与哈希表中，如果存在，我们直接返回答案。</p><p><img src="https://i.loli.net/2020/02/07/COeJNI5itlf8qLV.gif" alt="fig 1"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        hashmap <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> idx<span class="token punctuation">,</span> num <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> target <span class="token operator">-</span> num <span class="token keyword">in</span> hashmap<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>hashmap<span class="token punctuation">[</span>target <span class="token operator">-</span> num<span class="token punctuation">]</span><span class="token punctuation">,</span>idx<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                hashmap<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> idx</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(N)</li></ul><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><p>不妨我们趁热打铁，看看进阶题目！</p><ul><li>15.三数之和</li><li>18.四数之和</li></ul><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>373. Find K Pairs with Smallest Sums</title>
      <link href="/2020/01/24/0373/"/>
      <url>/2020/01/24/0373/</url>
      
        <content type="html"><![CDATA[<h3 id="解法一：暴力"><a href="#解法一：暴力" class="headerlink" title="解法一：暴力"></a>解法一：暴力</h3><p>枚举所有组合，按照和排序，最后返回前 K 项。</p><p><img src="https://i.loli.net/2020/02/03/jWNcHnoGpazt7wT.png" alt="fig 1"></p><pre class=" language-python3"><code class="language-python3">def kSmallestPairs(self, nums1, nums2, k):    return sorted(itertools.product(nums1, nums2), key=sum)[:k]</code></pre><h3 id="解法二：暴力标准解"><a href="#解法二：暴力标准解" class="headerlink" title="解法二：暴力标准解"></a>解法二：暴力标准解</h3><p>这个解法更加标准，因为上面的解法生成的是元组不是列表。</p><pre class=" language-python3"><code class="language-python3">def kSmallestPairs(self, nums1, nums2, k):    return map(list, sorted(itertools.product(nums1, nums2), key=sum)[:k])</code></pre><h3 id="解法三：优化的暴力"><a href="#解法三：优化的暴力" class="headerlink" title="解法三：优化的暴力"></a>解法三：优化的暴力</h3><p>仍然遍历所有对，但仅使用生成器和使用大小为 k 的堆<code>heapq.nsmallest</code>。 因此，这仅需要 O(k) 的额外内存和 O(mn log k) 的时间。</p><pre><code>def kSmallestPairs(self, nums1, nums2, k):    return map(list, heapq.nsmallest(k, itertools.product(nums1, nums2), key=sum))</code></pre><h3 id="解法四：堆"><a href="#解法四：堆" class="headerlink" title="解法四：堆"></a>解法四：堆</h3><p>不计算整个矩阵，而将每一行变成三元组<code>[u + v，u，v]</code>的生成器，仅在要求计算下一行时才计算下一行，然后将这些生成器与堆合并。 占用 O(m + k * log(m)) 的时间复杂度和 O(m) 的空间复杂度。</p><pre class=" language-python3"><code class="language-python3">def kSmallestPairs(self, nums1, nums2, k):    streams = map(lambda u: ([u+v, u, v] for v in nums2), nums1)    stream = heapq.merge(*streams)    return [suv[1:] for suv in itertools.islice(stream, k)]</code></pre><h3 id="解法五：优先队列"><a href="#解法五：优先队列" class="headerlink" title="解法五：优先队列"></a>解法五：优先队列</h3><p>它仅从矩阵左上角的第一对开始，然后根据需要从那里开始扩展。 每当将一对选择为输出结果时，该行中的下一对就会添加到当前选项的优先队列中。 同样，如果所选对是该行中的第一对，则将下一行中的第一对添加到队列中。</p><p><img src="https://i.loli.net/2020/02/03/u6yVbrnkLpZj1Io.png" alt="fig 2"></p><pre class=" language-python3"><code class="language-python3">class Solution:    def kSmallestPairs(self, nums1, nums2, k):        queue = []        def push(i, j):            if i < len(nums1) and j < len(nums2):                heapq.heappush(queue, [nums1[i] + nums2[j], i, j])        push(0, 0)        pairs = []        while queue and len(pairs) < k:            _, i, j = heapq.heappop(queue)            pairs.append([nums1[i], nums2[j]])            push(i, j + 1)            if j == 0:                push(i + 1, 0)        return pairs</code></pre><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>不是因为希望才去坚持，而是因为坚持才有了希望~加油！</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列和广度优先搜索（BFS）、栈和深度优先搜索（DFS）及Java模板</title>
      <link href="/2019/11/09/dui-lie-he-guang-du-you-xian-sou-suo-bfs-zhan-he-shen-du-you-xian-sou-suo-dfs-ji-java-mo-ban/"/>
      <url>/2019/11/09/dui-lie-he-guang-du-you-xian-sou-suo-bfs-zhan-he-shen-du-you-xian-sou-suo-dfs-ji-java-mo-ban/</url>
      
        <content type="html"><![CDATA[<p>本文为<a href="[https://leetcode-cn.com/explore/learn/card/queue-stack/217/queue-and-bfs/870/](https://leetcode-cn.com/explore/learn/card/queue-stack/217/queue-and-bfs/870/)">Leetcode</a>学习笔记</p><h2 id="队列和广度优先搜索（BFS）"><a href="#队列和广度优先搜索（BFS）" class="headerlink" title="队列和广度优先搜索（BFS）"></a>队列和广度优先搜索（BFS）</h2><p>广度优先搜索（BFS）的一个常见应用是找出从根结点到目标结点的最短路径。在本文中，我们提供了一个示例来解释在 BFS 算法中是如何逐步应用队列的。</p><h5 id="1-结点的处理顺序是什么？"><a href="#1-结点的处理顺序是什么？" class="headerlink" title="1. 结点的处理顺序是什么？"></a>1. 结点的处理顺序是什么？</h5><p>在第一轮中，我们处理根结点。在第二轮中，我们处理根结点旁边的结点；在第三轮中，我们处理距根结点两步的结点；等等等等。</p><p>与树的层序遍历类似，越是接近根结点的结点将越早地遍历。</p><p>如果在第 k 轮中将结点 X 添加到队列中，则根结点与 X 之间的最短路径的长度恰好是 k。也就是说，第一次找到目标结点时，你已经处于最短路径中。</p><h5 id="2-队列的入队和出队顺序是什么？"><a href="#2-队列的入队和出队顺序是什么？" class="headerlink" title="2. 队列的入队和出队顺序是什么？"></a>2. 队列的入队和出队顺序是什么？</h5><p>我们首先将根结点排入队列。然后在每一轮中，我们逐个处理已经在队列中的结点，并将所有邻居添加到队列中。值得注意的是，新添加的节点不会立即遍历，而是在下一轮中处理。</p><p>结点的处理顺序与它们添加到队列的顺序是完全相同的顺序，即先进先出（FIFO）。这就是我们在 BFS 中使用队列的原因。</p><blockquote><p>在特定问题中执行 BFS 之前确定结点和边缘非常重要。通常，结点将是实际结点或是状态，而边缘将是实际边缘或可能的转换。</p></blockquote><h5 id="模板-I"><a href="#模板-I" class="headerlink" title="模板 I"></a><em>模板 I</em></h5><pre><code>/** * Return the length of the shortest path between root and target node. */int BFS(Node root, Node target) {    Queue&lt;Node&gt; queue;  // store all nodes which are waiting to be processed    int step = 0;       // number of steps neeeded from root to current node    // initialize    add root to queue;    // BFS    while (queue is not empty) {        step = step + 1;        // iterate the nodes which are already in the queue        int size = queue.size();        for (int i = 0; i &lt; size; ++i) {            Node cur = the first node in queue;            return step if cur is target;            for (Node next : the neighbors of cur) {                add next to queue;            }            remove the first node from queue;        }    }    return -1;          // there is no path from root to target}</code></pre><ol><li>如代码所示，在每一轮中，队列中的结点是等待处理的结点。</li><li>在每个更外一层的 while 循环之后，我们距离根结点更远一步。变量 step 指示从根结点到我们正在访问的当前结点的距离。</li></ol><h5 id="模板II"><a href="#模板II" class="headerlink" title="模板II"></a><em>模板II</em></h5><p>有时，确保我们永远不会访问一个结点两次很重要。否则，我们可能陷入无限循环。如果是这样，我们可以在上面的代码中添加一个哈希集来解决这个问题。这是修改后的伪代码：</p><pre><code>/** * Return the length of the shortest path between root and target node. */int BFS(Node root, Node target) {    Queue&lt;Node&gt; queue;  // store all nodes which are waiting to be processed    Set&lt;Node&gt; used;     // store all the used nodes    int step = 0;       // number of steps neeeded from root to current node    // initialize    add root to queue;    add root to used;    // BFS    while (queue is not empty) {        step = step + 1;        // iterate the nodes which are already in the queue        int size = queue.size();        for (int i = 0; i &lt; size; ++i) {            Node cur = the first node in queue;            return step if cur is target;            for (Node next : the neighbors of cur) {                if (next is not in used) {                    add next to queue;                    add next to used;                }            }            remove the first node from queue;        }    }    return -1;          // there is no path from root to target}</code></pre><blockquote><p>有两种情况你不需要使用哈希集：</p><ol><li>你完全确定没有循环，例如，在树遍历中；</li><li>你确实希望多次将结点添加到队列中。</li></ol></blockquote><h2 id="栈和深度优先搜索（DFS）"><a href="#栈和深度优先搜索（DFS）" class="headerlink" title="栈和深度优先搜索（DFS）"></a>栈和深度优先搜索（DFS）</h2><p>与 BFS 类似，<strong>深度优先搜索</strong>（DFS）也可用于查找从根结点到目标结点的路径。在本文中，我们提供了示例来解释 DFS 是如何工作的以及栈是如何逐步帮助 DFS 工作的。<br><a href="https://leetcode-cn.com/explore/learn/card/queue-stack/219/stack-and-dfs/881/" target="_blank" rel="noopener">图</a></p><h5 id="1-结点的处理顺序是什么？-1"><a href="#1-结点的处理顺序是什么？-1" class="headerlink" title="1. 结点的处理顺序是什么？"></a>1. 结点的处理顺序是什么？</h5><p>在上面的例子中，我们从根结点 A 开始。首先，我们选择结点 B 的路径，并进行回溯，直到我们到达结点 E，我们无法更进一步深入。然后我们回溯到 A 并选择第二条路径到结点 C 。从 C 开始，我们尝试第一条路径到 E 但是 E 已被访问过。所以我们回到 C 并尝试从另一条路径到 F。最后，我们找到了 G。</p><p>总的来说，在我们到达最深的结点之后，我们只会回溯并尝试另一条路径。</p><blockquote><p>因此，你在 DFS 中找到的第一条路径并不总是最短的路径。例如，在上面的例子中，我们成功找出了路径 A-&gt; C-&gt; F-&gt; G 并停止了 DFS。但这不是从 A 到 G 的最短路径。</p></blockquote><h5 id="2-栈的入栈和退栈顺序是什么？"><a href="#2-栈的入栈和退栈顺序是什么？" class="headerlink" title="2. 栈的入栈和退栈顺序是什么？"></a>2. 栈的入栈和退栈顺序是什么？</h5><p>我们首先将根结点推入到栈中；然后我们尝试第一个邻居 B 并将结点 B 推入到栈中；等等等等。当我们到达最深的结点 E 时，我们需要回溯。当我们回溯时，我们将从栈中弹出最深的结点，这实际上是推入到栈中的最后一个结点。</p><p>结点的处理顺序是完全相反的顺序，就像它们被添加到栈中一样，它是后进先出（LIFO）。这就是我们在 DFS 中使用栈的原因。</p><p>正如我们在本章的描述中提到的，在大多数情况下，我们在能使用 BFS 时也可以使用 DFS。但是有一个重要的区别：<strong>遍历顺序</strong>。</p><p>与 BFS 不同，<strong>更早访问的结点可能不是更靠近根结点的结点</strong>。因此，你在 DFS 中找到的第一条路径<strong>可能不是最短路径</strong>。</p><h5 id="模板-递归"><a href="#模板-递归" class="headerlink" title="模板 - 递归"></a><em>模板 - 递归</em></h5><pre><code>/* * Return true if there is a path from cur to target. */boolean DFS(Node cur, Node target, Set&lt;Node&gt; visited) {    return true if cur is target;    for (next : each neighbor of cur) {        if (next is not in visited) {            add next to visted;            return true if DFS(next, target, visited) == true;        }    }    return false;}</code></pre><p>当我们递归地实现 DFS 时，似乎不需要使用任何栈。但实际上，我们使用的是由系统提供的隐式栈，也称为调用栈。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a><em>示例</em></h5><p>让我们看一个例子。我们希望在下图中找到结点 0 和结点 3 之间的路径。我们还会在每次调用期间显示栈的状态。<br><img src="https://upload-images.jianshu.io/upload_images/19942712-20b7c9e726b380f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Stack Status"><br>在每个堆栈元素中，都有一个整数 <strong>cur</strong>，一个整数 <strong>target</strong>，一个对<strong>访问过的</strong>数组的引用和一个对数组<strong>边界</strong>的引用，这些正是我们在 DFS 函数中的参数。我们只在上面的栈中显示 <strong>cur</strong>。</p><p>每个元素都需要固定的空间。栈的大小正好是 DFS 的深度。因此，在最坏的情况下，维护系统栈需要 O(h)，其中 h 是 DFS 的最大深度。在计算空间复杂度时，永远不要忘记考虑系统栈。</p><blockquote><p>在上面的模板中，我们在找到第一条路径时停止。<br>如果你想找到最短路径呢？<br>提示：再添加一个参数来指示你已经找到的最短路径。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法面试中应该注意的事</title>
      <link href="/2019/11/03/suan-fa-mian-shi-bi-xu-yao-zhu-yi-de-shi/"/>
      <url>/2019/11/03/suan-fa-mian-shi-bi-xu-yao-zhu-yi-de-shi/</url>
      
        <content type="html"><![CDATA[<p>通过学习拉勾网资深软件工程师su yong的算法面试课程，收获很大。如果您也有兴趣，欢迎点击<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=3#/detail/pc?id=29" target="_blank" rel="noopener">这里</a>聆听。下面对算法面试内容进行总结。</p><h1 id="刷题、简历、面试"><a href="#刷题、简历、面试" class="headerlink" title="刷题、简历、面试"></a>刷题、简历、面试</h1><h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><p>刷题是必不可少的环节。</p><p>无论你是刚刚毕业的计算机系的学生，还是已经有了很多年工作经验的工程师，你即将要面对的是高强度的面试。每个公司平均都有好几轮技术面试，包括电话面试和现场面试，每轮面试的时间是 45 分钟到 1 个小时，除去聊天谈话的时间，每一轮留给你的时间大概就是 30 分钟，要能拿到优秀的结果，一般都必须解答出两个算法题，而你要面试的公司可能不止一家。那么，要让自己始终保持良好的水准，没有一个强化训练的辅助，你是很难过关的，因此刷题就是必不可少的环节。</p><p>但是在刷题之前，必须要先弄清楚一个问题：你要选择什么编程语言？</p><h2 id="选择编程语言"><a href="#选择编程语言" class="headerlink" title="选择编程语言"></a>选择编程语言</h2><p>这往往取决于你的求职岗位是什么。</p><p>如果你要做一名前端的网络工程师，那么你必须要能熟练地用 JavaScript 去解算法题。如果你要做一名后端的工程师，那么可以选择的就很多了，其中 Java，Python 和 C++ 都是首选。如果你想要做一名数据分析工程师或者涉及机器学习和人工智能方向的，Pyhton 是不二选择。我自己方向是机器学习，因此我准备用python进行刷题。</p><p>讲师在刚开始刷题的时候用的是 Java，虽然他平时的工作并不用它，但是发现，用 Java 刷题有几个好处。</p><p>1. Java 是强类型语言，它能帮助更好地理解输入输出的要求，对于每个变量的类型都要清楚。</p><p>2. Java 提供丰富的类库，比如 Deque、PriorityQueue、LinkedList、Stack 等，有了这些，可以更加专注于对算法本身的思考，而不用考虑如何去实现这些数据结构。这些库拿来用就好，节省了很多时间。</p><p>3. LeetCode 上的很多题目都有 Java 的解法，如果一道题目做不出来，就会看看 LeetCode 的解法，比较方便。</p><p>后来讲师明确地知道自己要做一名前端的网络工程师，在决定跳槽去大厂的时候，不得不用 JavaScript 去重新刷题，这样一来，浪费了不少时间。所以在选择语言的时候，多考虑自己的求职方向和岗位要求。建议大量联系大厂的招聘专员，获取专业的建议。</p><h2 id="刷题方法"><a href="#刷题方法" class="headerlink" title="刷题方法"></a>刷题方法</h2><p>选择好了编程语言后，接下来要考虑的就是怎么合理地刷题了。</p><p>现在 LeetCode 上面有上千道题目，究竟要刷多少道题才行呢？其实最关键的不是量的问题，而是质的问题，而且由时间决定。</p><p>首先，根据自己平时的刷题速度，预留足够的刷题时间。</p><p>“我在刷题的时候，会给自己至少三个月的时间专心刷题，周一到周五每晚分配 2 个小时，周末也会刷。有时候由于要兼顾工作，平时晚上没有太多时间，我就会多留点时间到周末，把平时没有刷的题在周末补回来。根据平时的刷题速度，我可以计算出在这三个月的时间内，自己能一共做多少题。”</p><p>然后，刷题时可以有选择性地分类做题。</p><p>接下来，按照 LeetCode 的题目分类去做。先做树的题目，然后是图论，因为图论可以看作是树的一种扩展，然后是递归、回溯，之后是 DFS、BFS，然后是动态规划，最后是字符串和数组。分类刷题有如下几个好处。</p><p>1. 能有效地巩固知识点。</p><p>2. 帮助整理解题的思路和归纳方法。</p><p>3. 能有效地提高解题的速度。</p><p>另外，要练习如何在白板上写代码。</p><p>很多大厂都要求你在白板上写代码，大家不要小看了这点，很多人都认为用电脑做了几百道题之后，还怕在白板上写代码么？在白板上写代码的感觉跟敲键盘是完全不同的，有几点需要注意。</p><p>1. 字迹要清晰。这样一来面试官才能很好地跟你探讨代码，更重要的是，面试官要记录下你写的代码，然后原封不动地递交给招聘委员会的成员或者其他人审核，如果因为字迹不清导致记录失真就很不好了。</p><p>2. 间距要把握好。有些白板并不大，要能够在一块小白板上挤下很多代码是不可能的，这就要看你如何规划代码的书写了，这些都要通过不断地练习。</p><p>3. 思路清晰。写白板，是你和面试官沟通的一个重要环节，你的任务是要清晰地展现自己的思路，将它们转变为代码，并且，你要确保面试官能跟上你的节奏。如果你东写一点函数，西写一点结构定义，那就会很凌乱。</p><p>锻炼写白板的能力，最好的方法就是找一块白板，在它上面练习。一般这个可以在你拥有了一定的刷题量的基础上进行，不必一开始就这样练习。另外，也可以在纸上练习，把纸想象成白板，也能达到很不错的效果，尤其对锻炼清晰的笔迹有很大的帮助。</p><p>为了避免遗忘，养成整理回顾的习惯。</p><p>刷题的时候，会出现一种情况，之前刷过的题目一下就忘记了。要克服这种情况的出现，我用下面的办法。</p><p>1. 周末的时候回顾一下这一周做过的题目，主要是整理思路。</p><p>2. 把这周里出现的难啃的题目单独拿出来，记录到难题笔记里，反复看。</p><p>3. 刷题的时候，尽量把思路理清，而不是记代码。</p><p>最后，一定要把自己刷过的题目和最好的解法写下来。</p><p>我会按照老师的说法，把刷过的题目和最好的解法写下来，写到我的<a href="https://github.com/ML-ZimingMeng/python-problems-and-solutions" target="_blank" rel="noopener">github</a>上，欢迎一起交流。</p><h2 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h2><p>简历就是你的门面，好的简历能让你在众多的求职者中脱颖而出。很多公司的职位都是很有限的，如果招聘人员能够快速准确地从你的简历里找出他们想要的东西，比如你的技术，经验，或者研究成果等，那么你就会有更大地机会进入到面试的环节，另外，最重要的一点，想一想你为了能面试这家公司，付出了那么多的心血去刷题，最后因为简历没能被看上而与机会失之交臂，那是多么多么的不应该啊！可以说，好的简历是打开面试机会的大门。</p><p>怎么样去写好一份简历呢？</p><p>一、要有针对性</p><p>你的简历必须要凸显出你才是适合这个职务的不二人选。</p><p>每个职务的招聘一般都会有一些基本的要求，比如某个职务要招的是前端网络工程师，要求有 5 年以上的工作经验，精通 JavaScript，HTML5，CSS3，熟悉 React 框架等，那么你的简历必须要想办法体现出你能满足上面的基本要求。</p><p>可以通过你的工作履历表来体现出你有 5 年以上的工作经验，通过罗列出与前端相关的技术名词作为你所拥有和掌握的技术来体现你适合这个岗位的技术需求。有些人既懂得 Java，SQL，也懂得 JavaScript，但是在简历当中却把 JavaScript 罗列在了后面，有时候会让人觉得 JavaScript 也许并不是你的强项，也许你更适合做后端的工程师。换句话说，你的简历必须要能投其所好。</p><p>二、写好工作履历</p><p>招聘人员会把大部分时间花在阅读你的工作履历上。对于一个要谋求软件工程师职务的人的简历，必须要做到以下几点。</p><p>1. 对于以往的每一份工作，都必须写明公司的名称，起始时间和终止时间。</p><p>2. 针对每份工作，言简意赅地罗列出自己做过的项目，以及你在项目中扮演的角色。</p><p>3. 最好能体现出每个项目最终的结果以及所带来的影响。</p><p>在罗列项目的时候，最好能写明，你在这个项目中扮演的角色是什么，采用了什么样架构，使用了什么编程语言，解决了什么问题，达到了什么效果或者产生了什么样的影响。</p><p>三、控制页数</p><p>大厂的招聘人员，一般都会在每天分配出固定的时间来审阅大量的简历，你的简历一般都是以电子版的形式存储在系统中，招聘人员通过关键字搜索来找出合适的简历，然后加以阅读。通常，你的简历最好不要超过两页，最好能控制在一页。</p><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>当你拿到面试通知的时候，离成功就差最后一步了，只需要你在面试中好好表现，发挥出你的水平。</p><p>面试不光是脑力活，同时也是体力活，如何让你的脑力和体力都能跟上高强度的大厂技术面试呢？一种比较行之有效的方法就是多拿一些中小型公司练手。</p><p>中小型公司有时候比较倾向于考察你的经验，这是一个锻炼你跟面试官交流经验的绝佳机会，更重要的是，通过这些练手，能让你更好地梳理自己的技术经验，总结出适合你自己的交谈风格，这样，当你在大厂里被问到工作经验相关的问题时，就能脱口而出，而且条理清晰，这些其实跟刷题一样，都是要通过不断地练习的。</p><p>另外，中小型公司也会考察算法题，但是难度一般来说不会特别难，这是一个检验你算法和数据结构知识水平以及能不能写出高质量代码的难得的训练机会。有些中小型公司的技术面试也是出了名的难，如果你在这些面试中失败了，这是好事，你要从中吸取教训，把答得不好的题反复思考一下，在哪里跌倒就在哪里爬起来。</p><p>总之，通过一些真刀真枪地实战，可以帮助你迅速地调整面试的状态，记住，你的最终目标是你心仪的公司，不要被中间的一两个失利的战斗影响到自己，找出问题所在，为下一个面试做好准备。</p><p>下面说一下现场面试，现场面试真正要考察的是下面几个方面。</p><p>1. 你的技术水平够不够硬。</p><p>也就是说，你能不能在 30 分钟之类写出一道简单的题目以及一道中等甚至更难的题目。如果你的知识点不够牢固，写题的速度不够快，是非常难过这关的。但是，只要你努力刷题，一定会有好的结果。</p><p>2. 你分析问题的能力。</p><p>当面试官给你出问题的时候，他最希望的，并不是看到你拿到题目立即写出答案，而是希望你能跟他交流，把你的想法说明白。就好比你和面试官是同事，你们在一起讨论问题一样，只不过他对这个问题早已有了自己的想法，他想听听你的意见，说不定你的方法更好。</p><p>3. 你将思想变为代码的能力。</p><p>如果你和面试官的交流过程中，能始终呈现出一种状态，迅速地将自己的思考转变为代码，然后清晰地写在白板上。就算你不能完美地写出一道题目的答案，我相信面试官也一定会满意的，因为这要比那些只能夸夸其谈而写不出代码的人要强太多。</p><p>4. 检查和分析代码的能力。</p><p>一般在你写出了代码后，面试官会让你举几种情况来考虑看看你的算法是否行得通。最好的做法就是你自己要主动地提出来，然后给出几个比较有代表性的测试输入，然后过一遍你的程序，分析出结果。最后，一定要去分析一下时间和空间复杂度。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>老话说，“书山有路勤为径，学海无涯苦作舟“，共勉！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
