<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python 迭代器</title>
      <link href="/2020/02/28/python-iterator/"/>
      <url>/2020/02/28/python-iterator/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-迭代器"><a href="#Python-迭代器" class="headerlink" title="Python 迭代器"></a>Python 迭代器</h1><p>当我们创建一个列表的时候，列表中的元素也被创建，且占用内存。比如 <code>a_list = [1,2,3,4,5]</code>。</p><p>假如这个列表长度很大，几十万几百万的长度，使用列表时仍然会一次性创建所有元素，为了优化内存使用效率，我们可以一次创建一个元素，在需要的时候进行创建，这时可用到迭代器。</p><p>首先，需要了解两个重要的对象：</p><ul><li>可迭代对象（Iterable）</li><li>迭代器对象（Iterator）</li></ul><p>在如下实例中，我们使用 <code>isinstance()</code> 方法判断是否是可迭代对象或迭代器对象：</p><h4 id="实例1"><a href="#实例1" class="headerlink" title="实例1"></a>实例1</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> collections<span class="token punctuation">.</span>abc <span class="token keyword">import</span> Iterable<span class="token punctuation">.</span>Iterator<span class="token comment" spellcheck="true"># 区分是可迭代对象还是迭代器对象</span>a_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 是不是可迭代对象</span><span class="token keyword">print</span><span class="token punctuation">(</span>isinstance<span class="token punctuation">(</span>a_list<span class="token punctuation">,</span>Iterable<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 内置函数  True</span><span class="token keyword">print</span><span class="token punctuation">(</span>isinstance<span class="token punctuation">(</span>a_list<span class="token punctuation">,</span>Iterator<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 类型相同或者子类对象   False</span></code></pre><h4 id="实例2"><a href="#实例2" class="headerlink" title="实例2"></a>实例2</h4><pre class=" language-python"><code class="language-python">b <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> ragne<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 不再是list</span><span class="token keyword">print</span><span class="token punctuation">(</span>type<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 内置type 对象类型是生成器</span><span class="token keyword">print</span><span class="token punctuation">(</span>isinstance<span class="token punctuation">(</span>b<span class="token punctuation">,</span>Iterable<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 是可迭代对象</span><span class="token keyword">print</span><span class="token punctuation">(</span>isinstance<span class="token punctuation">(</span>b<span class="token punctuation">,</span>Iterator<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 是迭代器对象</span></code></pre><p>小结：</p><ol><li><p>for 循环遍历的对象都是可迭代对象。</p><pre class=" language-python"><code class="language-python">a_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token keyword">for</span> item <span class="token keyword">in</span> a_list<span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span></code></pre></li><li><p>如果是迭代器对象，都可以使用 <code>next()</code> 内置函数获取迭代器中的元素。</p><pre class=" language-python"><code class="language-python">b <span class="token operator">=</span> <span class="token punctuation">(</span>x <span class="token keyword">for</span> x <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>isinstance<span class="token punctuation">(</span>b<span class="token punctuation">.</span>Iterator<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span> </code></pre><p>需要用到元素的时候再取元素，比如第一次取是 1，第二次取是 2……</p><p>因此，Python 中有很多对象，list，dict，str，tuple属于可迭代对象，但不是所有的都是迭代器对象。</p></li><li><p>可使用 <code>iter()</code> 方法生成迭代器对象。</p><pre class=" language-python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 可迭代对象</span><span class="token comment" spellcheck="true"># 构造一个迭代器对象</span>b <span class="token operator">=</span> iter<span class="token punctuation">(</span>a<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 构造迭代器内置函数</span><span class="token keyword">print</span><span class="token punctuation">(</span>isiinstance<span class="token punctuation">(</span>b<span class="token punctuation">.</span>Iterator<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># True 是一个迭代器对象</span><span class="token comment" spellcheck="true"># 迭代器中的元素获取？</span><span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 第一次获取 1</span><span class="token keyword">print</span><span class="token punctuation">(</span>next<span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 第二次获取 2</span><span class="token keyword">for</span> i <span class="token keyword">in</span> b<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 获取元素的第二种方式</span></code></pre></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python3 </tag>
            
            <tag> 迭代器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题12. 矩阵中的路径</title>
      <link href="/2020/02/16/lcof12/"/>
      <url>/2020/02/16/lcof12/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题12-矩阵中的路径"><a href="#面试题12-矩阵中的路径" class="headerlink" title="面试题12. 矩阵中的路径"></a>面试题12. 矩阵中的路径</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/16/BvCiTIQ9VgfUw8A.png" alt=""></p><h3 id="解题思路：深度优先搜索-DFS"><a href="#解题思路：深度优先搜索-DFS" class="headerlink" title="解题思路：深度优先搜索 DFS"></a>解题思路：深度优先搜索 DFS</h3><p>我们可以将矩阵看作一个无向图。对于无向图，我们可以采用深度优先搜索和广度优先搜索两种办法进行遍历。</p><p><img src="https://pic.leetcode-cn.com/3aa75e29ee72da14df37229c76f21a2308a299fbb4800656f8f9b39f50d14d90-%E5%B9%BB%E7%81%AF%E7%89%8711.JPG" alt="幻灯片11.JPG"></p><p>因此对于 <code>word = ABCCEE</code>，我们可以先采用暴力搜索的办法找到目标字符串 <code>word</code> 中的第一个字符 <code>A</code>,找到之后按照深度优先搜索的顺序寻找是否有和 <code>word</code> 匹配的字符串，如果找到直接返回 <code>True</code>；如果没有，我们继续寻找下一个 <code>A</code>…</p><p>对于一轮深度搜索过程中，为了避免重复我们需要将搜索过的字符置为 <code>0</code>。</p><p><img src="https://pic.leetcode-cn.com/92e383cc1ca508f71d8eccd092c0333977651d7ce9de6672383981a2d78fb0c5-12.gif" alt="12.gif"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">exist</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> word<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 使用深度优先搜索</span>        <span class="token keyword">if</span> <span class="token operator">not</span> board<span class="token punctuation">:</span>   <span class="token comment" spellcheck="true"># 边界条件</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>board<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">:</span>                    <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span>    <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> board<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> word<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 如果单词已经检查完毕</span>            <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">if</span> i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">or</span> i <span class="token operator">>=</span> len<span class="token punctuation">(</span>board<span class="token punctuation">)</span> <span class="token operator">or</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">or</span> j <span class="token operator">>=</span> len<span class="token punctuation">(</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> word<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 如果路径出界或者矩阵中的值不是word的首字母，返回False</span>            <span class="token keyword">return</span> <span class="token boolean">False</span>        tmp <span class="token operator">=</span> board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 如果找到了第一个字母，检查剩余的部分</span>        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'0'</span>        res <span class="token operator">=</span> self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>board<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>word<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>board<span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>word<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>board<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>word<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> self<span class="token punctuation">.</span>dfs<span class="token punctuation">(</span>board<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token number">-1</span><span class="token punctuation">,</span> word<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 上下左右四个方向搜索</span>        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp        <span class="token keyword">return</span> res</code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">exist</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">,</span> string word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span>word<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">bool</span> <span class="token function">dfs</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">>></span><span class="token operator">&amp;</span> board<span class="token punctuation">,</span> string<span class="token operator">&amp;</span> word<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> j<span class="token punctuation">,</span><span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">>=</span>board<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span>j<span class="token operator">>=</span>board<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span>i<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span>j<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">||</span>length<span class="token operator">>=</span>word<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span>word<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token operator">!=</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>length<span class="token operator">==</span>word<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">&amp;&amp;</span>word<span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token operator">==</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">char</span> temp<span class="token operator">=</span>board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">'0'</span><span class="token punctuation">;</span>        <span class="token keyword">bool</span> flag<span class="token operator">=</span><span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span>word<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span>word<span class="token punctuation">,</span>i<span class="token punctuation">,</span>j<span class="token number">-1</span><span class="token punctuation">,</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span>word<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">||</span><span class="token function">dfs</span><span class="token punctuation">(</span>board<span class="token punctuation">,</span>word<span class="token punctuation">,</span>i<span class="token number">-1</span><span class="token punctuation">,</span>j<span class="token punctuation">,</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>        <span class="token keyword">return</span> flag<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(M\times N\times (M+N))$，$M$，$N$ 为矩阵的行数和列数。最坏情况下，<code>word</code>长度为 $O(M+N)$，且遍历了所有的元素，消耗时间为 $O(M\times N)$，故总的时间复杂度为 $O(M\times N\times (M+N))$。</li><li>空间复杂度：$O(1)$。</li></ul><p>如有问题，欢迎讨论~</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 深度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5342. 最多可以参加的会议数目</title>
      <link href="/2020/02/16/zui-duo-ke-yi-can-jia-de-hui-yi-shu-mu/"/>
      <url>/2020/02/16/zui-duo-ke-yi-can-jia-de-hui-yi-shu-mu/</url>
      
        <content type="html"><![CDATA[<h1 id="5342-最多可以参加的会议数目"><a href="#5342-最多可以参加的会议数目" class="headerlink" title="5342. 最多可以参加的会议数目"></a>5342. 最多可以参加的会议数目</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/16/koq2pG5by7zL1Ka.png" alt=""></p><h3 id="1-什么是优先队列"><a href="#1-什么是优先队列" class="headerlink" title="1. 什么是优先队列"></a>1. 什么是优先队列</h3><p>我们首先来回顾一下队列吧，队列是一种先进先出（FIFO）的数据结构，它的本质是一个线性表，只能在表的一端插入值，在表的另一端删除值。</p><ul><li>队尾（rear）：允许插入的一端；</li><li>队头（front）：允许删除的一端。<br><img src="https://pic.leetcode-cn.com/b625dfb997f7d1a45f3a060c4b1c90199fbea387702973e35bdd354fc12069f1-%E5%B9%BB%E7%81%AF%E7%89%871.JPG" alt="幻灯片1.JPG"></li></ul><p>优先队列也是一种队列，与队列不同的是，优先队列不再遵循先入先出的原则，而是分成了两种情况：</p><ul><li>最大优先队列，无论入队顺序，当前最大的元素优先出队。</li><li>最小优先队列，无论入队顺序，当前最小的元素优先出队。</li></ul><p>对于最小优先队列，队列中的每个元素都有一个权值，权值小的优先出队。假如我们将自身的数值作为权值，那么最小优先队列中较小的数会排在队列的前面，当加入一个新值 <code>3</code> 时，<code>3</code> 会在队列中处于合适的位置。<br><img src="https://pic.leetcode-cn.com/9a5fe2634473a792d6644492a465905c041c156f1362624aea924958192d1991-%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE.png" alt="最多可以参加的会议.png"></p><p>当进行出队操作时，每次会从队首弹出队列中最小的元素：<br><img src="https://pic.leetcode-cn.com/1f0822918ada35f96954f49b074263c9747865409c466add72ab708b8e5d9258-%E5%B9%BB%E7%81%AF%E7%89%872.PNG" alt="幻灯片2.PNG"></p><p>最大优先队列则与之相反，最先弹出队列中最大的元素。</p><p>事实上，优先队列的本质上是一个堆，它是一棵完全二叉树，分为小顶堆和大顶堆：</p><ul><li>小顶堆是每一个根节点小于左右子节点的完全二叉树，堆顶元素最小，对应最小优先队列；</li><li>大顶堆是每一个根节点大于左右子节点的完全二叉树，堆顶元素最大，对应最大优先队列；</li></ul><p>由于删除堆顶元素时的时间复杂度为 $O(logN)$，因此在优先队列中入队和出队操作的时间复杂度也是 $O(logN)$。</p><h3 id="2-解题思路"><a href="#2-解题思路" class="headerlink" title="2. 解题思路"></a>2. 解题思路</h3><p>贪心思想：<strong>为了能参加最多的会议，我们尽量每次参加开始时间最早的会议。</strong> 注意以下问题：</p><ol><li>比如某会议时间是 <code>[1,10]</code>，那么我们先尽量尝试第 <code>1</code> 天参加，如果参加了别的会议，再尝试第 <code>2</code> 天…</li><li>如果两个会议开始时间相同，我们优先选择结束时间早的那个会议。比如 <code>[1,4]</code> 和 <code>[1,3]</code>，利用优先队列，第 <code>1</code> 天先参加 <code>[1,3]</code>，第 <code>2</code> 天参加 <code>[1,4]</code>。<h4 id="算法："><a href="#算法：" class="headerlink" title="算法："></a>算法：</h4>我们将 <code>events</code> 按照最小优先队列（小顶堆）的结构来储存，当队列不为空时，弹出队首元素，</li><li>判断能否参加会议，若结束时间小于当天，说明过期了不能参加，跳过；</li><li>如果可以参加，比较当天和开始时间：<ul><li>如果当天大于开始时间，说明我们没有必要非在今天参加，把 <code>[当天，结束时间]</code>重新加入优先队列，以查找有没有只能在今天参加的会议；</li><li>如果当天等于开始时间，我们立即开始这个会议。因为优先队列保证开始时间相同时结束时间是递增的。</li></ul></li></ol><p><img src="https://i.loli.net/2020/02/16/rpolRWYUaIh2ZMu.gif" alt="Priority queue"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxEvents</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> events<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token number">0</span>        heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>events<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 把events转化成堆结构</span>        cur <span class="token operator">=</span> events<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> events<span class="token punctuation">:</span>            s<span class="token punctuation">,</span> e <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>events<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># print([s,e])</span>            <span class="token keyword">if</span> e <span class="token operator">&lt;</span> cur<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 如果结束时间小于当前天，说明过期了，不能参加</span>                <span class="token keyword">continue</span>            <span class="token comment" spellcheck="true"># 如果开始时间小于当天，我们也不必今天参加，可以在（当天，结束天）任何一天参加</span>            <span class="token keyword">if</span> s <span class="token operator">&lt;</span> cur<span class="token punctuation">:</span>                 heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>events<span class="token punctuation">,</span><span class="token punctuation">[</span>cur<span class="token punctuation">,</span>e<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                cur <span class="token operator">=</span> max<span class="token punctuation">(</span>cur <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>s <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                res <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res </code></pre><p>如有问题，欢迎讨论~</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 优先队列 </tag>
            
            <tag> 力扣周赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题13. 机器人的运动范围</title>
      <link href="/2020/02/16/lcof13/"/>
      <url>/2020/02/16/lcof13/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题13-机器人的运动范围"><a href="#面试题13-机器人的运动范围" class="headerlink" title="面试题13. 机器人的运动范围"></a>面试题13. 机器人的运动范围</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/16/VoMOHsbJNZ26Rqz.png" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="1-如何计算行坐标和列坐标的数位之和"><a href="#1-如何计算行坐标和列坐标的数位之和" class="headerlink" title="1. 如何计算行坐标和列坐标的数位之和"></a><em>1. 如何计算行坐标和列坐标的数位之和</em></h4><p>对于一个整数 n，我们有以下伪代码模板：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sum <span class="token operator">+</span><span class="token operator">=</span> n <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// n对10取余</span>        n <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// n等于整除10之后的值</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token punctuation">;</span></code></pre><p>因此我们只需将行坐标和列坐标分别求数位之和，将其结果相加即可。</p><h4 id="2-哪些格子在运动范围之内"><a href="#2-哪些格子在运动范围之内" class="headerlink" title="2. 哪些格子在运动范围之内"></a><em>2. 哪些格子在运动范围之内</em></h4><p>机器人的运动范围需要同时满足以下两个条件：</p><ul><li>当前格子坐标数位之和不大于 k；</li><li>从坐标 <code>(0, 0)</code> 通过上下左右移动可以到达当前格子</li></ul><p><img src="https://pic.leetcode-cn.com/793fef4ce36d1e8e35d0fa2d02ec12dbe5a7532960a9e18360f101abc0b7e51c-1.png" alt="1.png"></p><p>对于上面的矩阵 <code>m = 4, n = 12, k = 2</code>，蓝色区域是满足条件的格子，所以返回结果为 <code>6</code>。需要注意的是，黄色区域虽然满足数位之和不大于 <code>k</code>，但是由于不满足第二个条件，即无法从 <code>(0, 0)</code> 位置移动过去，故不计算在结果之内。</p><p>我们可以将矩阵看作一个有向图，而遍历图的方式一般分为广度优先搜索（BFS）和深度优先搜索（DFS），因此从 <code>(0, 0)</code> 点出发，采用 BFS 或 DFS ，如果当前格子满足以上两个条件，则将结果加 1。</p><h4 id="方法一：广度优先搜索-BFS"><a href="#方法一：广度优先搜索-BFS" class="headerlink" title="方法一：广度优先搜索 BFS"></a>方法一：广度优先搜索 BFS</h4><p>广度优先搜索一般使用队列来实现。我们先将 <code>(0, 0)</code>加入队列，当队列不为空时，每次将队首坐标出队，加入到集合中，再将满足以上两个条件的坐标加入到队尾，直到队列为空。<br><img src="https://pic.leetcode-cn.com/94f5ce51bf0ebf4f2b0c7ee8913dd5c2bd2f8be933102fb9f6ea43e4158236d4-1.gif" alt="1.gif"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">sum_rc</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>row<span class="token punctuation">,</span>col<span class="token punctuation">)</span><span class="token punctuation">:</span>        tmp <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> row <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            tmp <span class="token operator">+=</span> row <span class="token operator">%</span> <span class="token number">10</span>            row <span class="token operator">//=</span> <span class="token number">10</span>        <span class="token keyword">while</span> col <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            tmp <span class="token operator">+=</span> col <span class="token operator">%</span> <span class="token number">10</span>            col <span class="token operator">//=</span> <span class="token number">10</span>        <span class="token keyword">return</span> tmp    <span class="token keyword">def</span> <span class="token function">movingCount</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        marked <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 将访问过的点添加到集合marked中,从(0,0)开始</span>        queue <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">)</span>        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> queue<span class="token punctuation">:</span>            x<span class="token punctuation">,</span> y <span class="token operator">=</span> queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token operator">not</span> <span class="token keyword">in</span> marked <span class="token operator">and</span> self<span class="token punctuation">.</span>sum_rc<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> k<span class="token punctuation">:</span>                marked<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token keyword">for</span> dx<span class="token punctuation">,</span> dy <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> x <span class="token operator">+</span> dx <span class="token operator">&lt;</span> m <span class="token operator">and</span> <span class="token number">0</span> <span class="token operator">&lt;=</span> y <span class="token operator">+</span> dy <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>                        queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token operator">+</span>dx<span class="token punctuation">,</span>y<span class="token operator">+</span>dy<span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token keyword">return</span> len<span class="token punctuation">(</span>marked<span class="token punctuation">)</span>    </code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：$O(m\times n)$。</li><li>空间复杂度：$O(m\times n)$。<h4 id="方法二：深度优先搜索-DFS"><a href="#方法二：深度优先搜索-DFS" class="headerlink" title="方法二：深度优先搜索 DFS"></a>方法二：深度优先搜索 DFS</h4>深度优先搜索一般使用栈来实现。本题使用递归可以更轻松实现，我们定义一个递归函数 <code>dfs()</code>，如果坐标不满足条件，结束递归状态，否则将下一步满足条件的坐标代入递归函数。<br><img src="https://pic.leetcode-cn.com/146310e1ffc5883926d5674efcc345c71ee1cd997e586ed2f29eb1cbb29f8eb3-2.gif" alt="2.gif"></li></ul><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">movingCount</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> m<span class="token punctuation">:</span> int<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">,</span> k<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">sum_ij</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 定义和函数</span>            tmp <span class="token operator">=</span> <span class="token number">0</span>            <span class="token keyword">while</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>                tmp <span class="token operator">+=</span> i <span class="token operator">%</span> <span class="token number">10</span>                i <span class="token operator">//=</span> <span class="token number">10</span>            <span class="token keyword">while</span> j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>                tmp <span class="token operator">+=</span> j <span class="token operator">%</span> <span class="token number">10</span>                j <span class="token operator">//=</span> <span class="token number">10</span>            <span class="token keyword">return</span> tmp         <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span> <span class="token keyword">in</span> self<span class="token punctuation">.</span>marked <span class="token operator">or</span> i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">or</span> i <span class="token operator">>=</span> m <span class="token operator">or</span> j <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">or</span> j <span class="token operator">>=</span> n<span class="token punctuation">:</span>                <span class="token keyword">return</span>             self<span class="token punctuation">.</span>marked<span class="token punctuation">.</span>add<span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> sum_ij<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> k<span class="token punctuation">:</span>                self<span class="token punctuation">.</span>res <span class="token operator">+=</span> <span class="token number">1</span>                dfs<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>                dfs<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token number">-1</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>marked <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span>        self<span class="token punctuation">.</span>res <span class="token operator">=</span> <span class="token number">0</span>        dfs<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>res</code></pre><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li>时间复杂度：$O(m\times n)$。</li><li>空间复杂度：$O(m\times n)$。</li></ul><p>如有问题，欢迎讨论~</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题31. 栈的压入、弹出序列</title>
      <link href="/2020/02/16/lcof31/"/>
      <url>/2020/02/16/lcof31/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题31-栈的压入、弹出序列"><a href="#面试题31-栈的压入、弹出序列" class="headerlink" title="面试题31. 栈的压入、弹出序列"></a>面试题31. 栈的压入、弹出序列</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/16/q78LlsEIb5OStyT.png" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>思路很简单，我们尝试按照 <code>popped</code> 中的顺序模拟一下出栈操作，如果符合则返回 <code>true</code>，否则返回 <code>false</code>。</p><p>我们使用一个栈 <code>st</code> 来模拟该操作。将 <code>pushed</code> 数组中的每个数依次入栈，同时判断这个数是不是 <code>popped</code> 数组中下一个要 <code>pop</code> 的值，如果是就把它 <code>pop</code> 出来。最后检查栈是否为空。</p><p><img src="https://i.loli.net/2020/02/16/oJkDbQliU9nfLAd.gif" alt="fig 1"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">validateStackSequences</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> pushed<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> popped<span class="token punctuation">)</span> <span class="token punctuation">{</span>        stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> st<span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> popped<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pushed<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            st<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>pushed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> st<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> popped<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                st<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">++</span>j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> st<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">validateStackSequences</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> pushed<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> popped<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        j <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> x <span class="token keyword">in</span> pushed<span class="token punctuation">:</span>            stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>x<span class="token punctuation">)</span>            <span class="token keyword">while</span> stack <span class="token operator">and</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>popped<span class="token punctuation">)</span> <span class="token operator">and</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> popped<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                j <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> <span class="token operator">not</span> stack</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(N)$。将所以元素一遍入栈，一遍出栈，需要 $O(2N)$。</li><li>空间复杂度：$O(N)$。使用了辅助栈 <code>st</code>。</li></ul><p>如果您有任何建议欢迎讨论~</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题44. 数字序列中某一位的数字</title>
      <link href="/2020/02/16/lcof44/"/>
      <url>/2020/02/16/lcof44/</url>
      
        <content type="html"><![CDATA[<h1 id="面试题44-数字序列中某一位的数字"><a href="#面试题44-数字序列中某一位的数字" class="headerlink" title="面试题44. 数字序列中某一位的数字"></a>面试题44. 数字序列中某一位的数字</h1><h3 id="题目描述（难度：简单）"><a href="#题目描述（难度：简单）" class="headerlink" title="题目描述（难度：简单）"></a>题目描述（难度：简单）</h3><p><img src="https://i.loli.net/2020/02/16/Mb96FKncWAdSQwm.png" alt=""></p><h3 id="思路一：找规律"><a href="#思路一：找规律" class="headerlink" title="思路一：找规律"></a>思路一：找规律</h3><p>我们通过观察，可以发现以下规律：</p><p><img src="https://pic.leetcode-cn.com/4f913f7a795d55038dc3a480c8268d8cc3367b14cb0cb4a7ea0c9d23f26fff9b-1.png" alt="1.png"></p><p>对于第 n 位对应的数字，我们令这个数字对应的数为 <code>target</code>，然后分三步进行。</p><ul><li>首先找到这个数字对应的数是几位数，用 <code>digits</code> 表示；</li><li>然后确定这个对应的数的数值 <code>target</code>；</li><li>最后确定返回值是 <code>target</code> 中的哪个数字。</li></ul><p>举个栗子：</p><p>比如输入的 n 是 <code>365</code>：</p><ol><li><p>经过第一步计算我们可以得到第 365 个数字表示的数是三位数，$n=365-9-90\times2=176$，<code>digtis = 3</code>。这时 $n=176$ 表示目标数字是三位数中的第 $176$ 个数字。</p></li><li><p>我们设目标数字所在的数为 <code>number</code>，计算得到 $number=100+176/3=158$，<code>idx</code> 是目标数字在 <code>number</code> 中的索引，如果 <code>idx = 0</code>，表示目标数字是 <code>number</code> 中的最后一个数字。</p></li><li><p>根据步骤2，我们可以计算得到 <code>idx = n % digits = 176 % 3 = 2</code>，说明目标数字应该是 <code>number = 158</code> 中的第二个数字，即输出为 <code>5</code>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3></li></ol><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findNthDigit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 首先判断target是几位数，用digits表示</span>        base <span class="token operator">=</span> <span class="token number">9</span>        digits <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">while</span> n <span class="token operator">-</span> base <span class="token operator">*</span> digits <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            n <span class="token operator">-=</span> base <span class="token operator">*</span> digits            base <span class="token operator">*=</span> <span class="token number">10</span>            digits <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token comment" spellcheck="true"># 计算target的值</span>        idx <span class="token operator">=</span> n <span class="token operator">%</span> digits  <span class="token comment" spellcheck="true"># 注意由于上面的计算，n现在表示digits位数的第n个数字</span>        <span class="token keyword">if</span> idx <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>             idx <span class="token operator">=</span> digits        number <span class="token operator">=</span> <span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>digits<span class="token punctuation">)</span><span class="token punctuation">:</span>            number <span class="token operator">*=</span> <span class="token number">10</span>        <span class="token keyword">if</span> idx <span class="token operator">==</span> digits<span class="token punctuation">:</span>            number <span class="token operator">+=</span> n <span class="token operator">//</span> digits <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            number <span class="token operator">+=</span> n <span class="token operator">//</span> digits        <span class="token comment" spellcheck="true"># 找到target中对应的数字</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>idx<span class="token punctuation">,</span>digits<span class="token punctuation">)</span><span class="token punctuation">:</span>            number <span class="token operator">//=</span> <span class="token number">10</span>        <span class="token keyword">return</span> number <span class="token operator">%</span> <span class="token number">10</span></code></pre><pre class=" language-c++"><code class="language-c++">class Solution {public:    int findNthDigit(int n) {        // 计算该数字由几位数字组成，由1位：digits = 1；2位：digits = 2...        long base = 9,digits = 1;        while (n - base * digits > 0){            n -= base * digits;            base *= 10;            digits ++;        }        // 计算真实代表的数字是多少        int idx = n % digits;  // 注意由于上面的计算，n现在表示digits位数的第n个数字        if (idx == 0)idx = digits;        long number = 1;        for (int i = 1;i < digits;i++)            number *= 10;        number += (idx == digits)? n/digits - 1:n/digits;        // 从真实的数字中找到我们想要的那个数字        for (int i=idx;i<digits;i++) number /= 10;        return number % 10;    }};</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。<h3 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h3>掌握了方法之后可以对代码进行简化，思路与之前一样，这里注意的是 <code>first_num</code> 表示每组数的第一个数。</li></ul><p><img src="https://pic.leetcode-cn.com/5a7b1f4a799ca649835939d7e1fdbc051c0e46506f0ccca703fa79d3028726b3-2.png" alt="2.png"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">findNthDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        n <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> digits<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>digits <span class="token operator">&lt;</span> <span class="token number">11</span><span class="token punctuation">;</span><span class="token operator">++</span>digits <span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> first_num <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span>digits<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">9</span> <span class="token operator">*</span> first_num <span class="token operator">*</span> digits<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token function">to_string</span><span class="token punctuation">(</span>first_num <span class="token operator">+</span> n<span class="token operator">/</span>digits<span class="token punctuation">)</span><span class="token punctuation">[</span>n<span class="token operator">%</span>digits<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token string">'0'</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            n <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">9</span> <span class="token operator">*</span> first_num <span class="token operator">*</span> digits<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">findNthDigit</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>        n <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">for</span> digits <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            first_num <span class="token operator">=</span> <span class="token number">10</span><span class="token operator">**</span><span class="token punctuation">(</span>digits <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> n <span class="token operator">&lt;</span> <span class="token number">9</span> <span class="token operator">*</span> first_num <span class="token operator">*</span> digits<span class="token punctuation">:</span>                <span class="token keyword">return</span> int<span class="token punctuation">(</span>str<span class="token punctuation">(</span>first_num <span class="token operator">+</span> n<span class="token operator">/</span>digits<span class="token punctuation">)</span><span class="token punctuation">[</span>n<span class="token operator">%</span>digits<span class="token punctuation">]</span><span class="token punctuation">)</span>            n <span class="token operator">-=</span> <span class="token number">9</span> <span class="token operator">*</span> first_num <span class="token operator">*</span> digits</code></pre><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(N)$。</li><li>空间复杂度：$O(1)$。</li></ul><p>如有问题，欢迎讨论~</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>08.06. Hanota LCCI</title>
      <link href="/2020/02/14/con0806/"/>
      <url>/2020/02/14/con0806/</url>
      
        <content type="html"><![CDATA[<h1 id="08-06-Hanota-LCCI"><a href="#08-06-Hanota-LCCI" class="headerlink" title="08.06. Hanota LCCI"></a>08.06. Hanota LCCI</h1><blockquote><p>相传在很久以前，有个寺庙里的几个和尚整天不停地移动着 64 个盘子，日复一日，年复一年。据说，当 64 个盘子全部移完的那一天就是世界末日…</p></blockquote><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="https://i.loli.net/2020/02/14/i3qNER9GvYDpPX1.png" alt=""><br>有 A,B,C 三根柱子，A 上面有 n 个盘子，我们想把 A 上面的盘子移动到 C 上，但是要满足以下三个条件：</p><ol><li>每次只能移动一个盘子;</li><li>盘子只能从柱子顶端滑出移到下一根柱子;</li><li>盘子只能叠在比它大的盘子上。</li></ol><p><img src="https://pic.leetcode-cn.com/7043dec266338d396d186805072660d5f9517e2c1008af80d461b553c5b32470-p1.png" alt="p1.png"></p><h3 id="解题思路：递归与分治"><a href="#解题思路：递归与分治" class="headerlink" title="解题思路：递归与分治"></a>解题思路：递归与分治</h3><p>这是一道递归方法的经典题目，乍一想还挺难理清头绪的，我们不妨先从简单的入手。</p><p>假设 <code>n = 1</code>,只有一个盘子，很简单，直接把它从 A 中拿出来，移到 C 上；</p><p>如果 <code>n = 2</code> 呢？这时候我们就要借助 B 了，因为小盘子必须时刻都在大盘子上面，共需要 4 步。</p><p><img src="https://pic.leetcode-cn.com/f6f3b97651247c9ff846f115e1866ab364b1c0e265fd51689ddd6a8ca1758482-0806.gif" alt="0806.gif"></p><p>如果  <code>n &gt; 2</code> 呢？思路和上面是一样的，我们把 n 个盘子也看成两个部分，一部分有 1 个盘子，另一部分有 n - 1 个盘子。</p><p><img src="https://pic.leetcode-cn.com/3bffd1a1faf4323a92b659e37d7e2cd6c79fe074602b2977f4a7931fe82bbb13-08061.gif" alt="08061.gif"></p><p>观察上图，你可能会问：“那 n - 1 个盘子是怎么从 A 移到 C 的呢？”</p><p>注意，<strong>当你在思考这个问题的时候，就将最初的 n 个盘子从 A 移到 C 的问题，转化成了将 n - 1 个盘子从 A 移到 C 的问题，</strong> 依次类推，直至转化成 1 个盘子的问题时，问题也就解决了。这就是分治的思想。 </p><p>而实现分治思想的常用方法就是递归。不难发现，如果原问题可以分解成若干个与原问题结构相同但规模较小的子问题时，往往可以用递归的方法解决。具体解决办法如下：</p><ul><li><code>n = 1</code>时，直接把盘子从 A 移到 C；</li><li><code>n &gt; 1</code>时,<ul><li>先把上面 n - 1 个盘子从 A 移到 B（子问题，递归）；</li><li>再将最大的盘子从 A 移到 C；</li><li>再将 B 上 n - 1 个盘子从 B 移到 C（子问题，递归）。</li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">hanota</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> A<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> B<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> C<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> None<span class="token punctuation">:</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>A<span class="token punctuation">)</span>        self<span class="token punctuation">.</span>move<span class="token punctuation">(</span>n<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 定义move 函数移动汉诺塔</span>    <span class="token keyword">def</span> <span class="token function">move</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>n<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>            C<span class="token punctuation">.</span>append<span class="token punctuation">(</span>A<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            A<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span>         <span class="token keyword">else</span><span class="token punctuation">:</span>            self<span class="token punctuation">.</span>move<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> A<span class="token punctuation">,</span> C<span class="token punctuation">,</span> B<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 将A上面n-1个通过C移到B</span>            C<span class="token punctuation">.</span>append<span class="token punctuation">(</span>A<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>          <span class="token comment" spellcheck="true"># 将A最后一个移到C</span>            A<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true"># 这时，A空了</span>            self<span class="token punctuation">.</span>move<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span>B<span class="token punctuation">,</span> A<span class="token punctuation">,</span> C<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true"># 将B上面n-1个通过空的A移到C</span></code></pre><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">void</span> <span class="token function">hanota</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> B<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> C<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> A<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">move</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> A<span class="token punctuation">,</span> B<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> A<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> B<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> C<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            C<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            A<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">move</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> A<span class="token punctuation">,</span> C<span class="token punctuation">,</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将A上面n-1个通过C移到B</span>        C<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 将A最后一个移到C</span>        A<span class="token punctuation">.</span><span class="token function">pop_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 这时，A空了</span>        <span class="token function">move</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span> B<span class="token punctuation">,</span> A<span class="token punctuation">,</span> C<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 将B上面n-1个通过空的A移到C</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="复杂度分析：世界会毁灭吗"><a href="#复杂度分析：世界会毁灭吗" class="headerlink" title="复杂度分析：世界会毁灭吗"></a>复杂度分析：世界会毁灭吗</h3><ul><li>时间复杂度：$O(2^n-1)$。一共需要移动的次数。</li><li>空间复杂度：$O(1)$。</li></ul><p>当 <code>n = 64</code>时，也就是有 64 个盘子的时候，如果每秒移动一个盘子，大约需要 $1.8\times10^{19}$ 秒…</p><p>那个时候地球会毁灭吗？</p><p>也许会，也许不会。</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 递归 </tag>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1347. Minimum Number of Steps to Make Two Strings Anagram</title>
      <link href="/2020/02/10/1347/"/>
      <url>/2020/02/10/1347/</url>
      
        <content type="html"><![CDATA[<h1 id="1347-Minimum-Number-of-Steps-to-Make-Two-Strings-Anagram"><a href="#1347-Minimum-Number-of-Steps-to-Make-Two-Strings-Anagram" class="headerlink" title="1347. Minimum Number of Steps to Make Two Strings Anagram"></a>1347. Minimum Number of Steps to Make Two Strings Anagram</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/10/fjP6h4bpeqv53Fo.png" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>首先，我们发现字母异位词 <code>s</code> 和 <code>t</code> 中，每个字母出现的次数相同，位置可能相同也可能不同，比如 <code>anagram</code> 和 <code>mangaar</code>，或者 <code>xxyyzz</code> 和 <code>xxyyzz</code>。因此我们在求解的时候，无需考虑位置，只需考虑两个字符串中字母出现的位置。</p><p>因此，使用数组记录每个字母出现的次数:</p><p>$字母i出现的次数=s中字母i出现的次数-t中字母i出现的次数$</p><p>出现次数有正有负，只需将正值加起来即可。</p><p><img src="https://i.loli.net/2020/02/10/hg5S8ckodMRGLQx.gif" alt="fig 1"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>python</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">minSteps</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> t<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        cnt <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">26</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            cnt<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>            cnt<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>t<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> ord<span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>        res <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> cnt<span class="token punctuation">:</span>            <span class="token keyword">if</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>                res <span class="token operator">+=</span> i        <span class="token keyword">return</span> res</code></pre><p>C++</p><pre class=" language-C++"><code class="language-C++">class Solution {public:    int minSteps(string s, string t) {        int res = 0;        vector<int> tmp(26,0);        for(int i = 0; i< s.size();i++){            tmp[s[i] - 'a']++;            tmp[t[i] - 'a']--;        }        for (int i = 0;i < 26;++i){            if(tmp[i] > 0) res += abs(tmp[i]);        }        return res;    }};</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N)。</li><li>空间复杂度：O(N)。</li></ul><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1349. Maximum Students Taking Exam</title>
      <link href="/2020/02/10/5335/"/>
      <url>/2020/02/10/5335/</url>
      
        <content type="html"><![CDATA[<h1 id="1349-Maximum-Students-Taking-Exam"><a href="#1349-Maximum-Students-Taking-Exam" class="headerlink" title="1349. Maximum Students Taking Exam"></a>1349. Maximum Students Taking Exam</h1><h3 id="题目描述（难度：困难）"><a href="#题目描述（难度：困难）" class="headerlink" title="题目描述（难度：困难）"></a>题目描述（难度：困难）</h3><p><img src="https://i.loli.net/2020/02/10/Xlvjpb7kne9JM1O.png" alt=""></p><h3 id="1-什么是动态规划（dynamic-programming，DP）"><a href="#1-什么是动态规划（dynamic-programming，DP）" class="headerlink" title="1. 什么是动态规划（dynamic programming，DP）"></a>1. 什么是动态规划（dynamic programming，DP）</h3><p>很多情况下我们都把动态规划想得太复杂了，我也是其中一个。quora 上有一个回答是这么说的：</p><ul><li>首先在一张纸上写下 $1+1+1+1+1+1+1+1=？$</li><li>“它等于多少呢？”</li><li>我们会立即脱口而出，“等于8！”</li><li>如果我们在左边添一个 $1 +$</li><li>“会等于多少呢？”</li><li>当然，不用想，“等于9！”</li><li>“为什么你会计算得这么快呢？”</li><li>“因为 $8+1=9$”</li></ul><p>所以，我们没有重新计算 $1+1+1+1+1+1+1+1+1$ 的值因为我们记住了前面的和等于8，所以再次计算时只需再加 1 就可以了。</p><p><strong>我们通过记住一些事情来节省时间，这就是动态规划的精髓。</strong> 具体来说，如果一个问题的子问题会被我们重复利用，我们则可以考虑使用动态规划。</p><h3 id="2-什么是状态压缩-DP"><a href="#2-什么是状态压缩-DP" class="headerlink" title="2. 什么是状态压缩 DP"></a>2. 什么是状态压缩 DP</h3><p>一般来说，动态规划使用一个一维数组或者二维数组来保存状态。</p><p>比如 <a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">42.接雨水</a> 中，我们使用<strong>一维数组</strong> <code>dp[i]</code> 表示下标 <code>i</code>左边最高柱子的高度。<code>dp[i]</code> 包含了两个信息：</p><ul><li>下标 <code>i</code> 左边的柱子</li><li>最高的高度值</li></ul><p>比如 <a href="https://leetcode-cn.com/problems/regular-expression-matching/" target="_blank" rel="noopener">10.正则表达式匹配</a> 中，我们使用<strong>二维数组</strong> <code>dp[i][j]</code> 表示 字符串 <code>s</code> 的前 <code>i</code> 项和 <code>t</code> 的前 <code>j</code> 项是否匹配。<code>dp[i][j]</code> 包含了三个信息：</p><ul><li><code>s</code> 的前 <code>i</code> 项</li><li><code>t</code> 的前 <code>j</code> 项</li><li>是否匹配</li></ul><p>对于本题来讲，通过分析，我们也可以表示类似的状态，<code>dp[i][j]</code> 表示当第 <code>i</code> 行的座位分布为 <code>j</code> 时，前 <code>i</code> 行可容纳的最大学生人数。但如果我们还想知道第 <code>i</code> 行有多少个座位呢？这无疑多了一个维度，这时我们不能用类似 <code>dp[i][j][k]</code> 来表示了，因为计算机中没有类似三维的数据结构。</p><p>这时候状态中所包含的信息过多，该怎么办呢？我们可以<strong>利用二进制以及位运算来实现对于本来应该很大的数组的操作，这就是状态压缩</strong>，而使用状态压缩来保存状态的 DP 就叫做状态压缩 DP。</p><h3 id="3-解题思路"><a href="#3-解题思路" class="headerlink" title="3. 解题思路"></a>3. 解题思路</h3><p><em>1. 用位编码表示状态</em></p><p>题目中提到 m，n 不超过 8，图我们可以使用位编码记录每一行的状态，即当椅子上坐了一个人时，我们将该位置设为 1，如下图所示：</p><p><img src="https://pic.leetcode-cn.com/8de2c203dbd8f489999ad92a0dfca24914770c692d9b4a4779e0b1a4433d0020-file_1581261113779" alt="p1.png"></p><p><em>2. 判断此状态是否有效</em><br>对于如下图的座位中，我们看到坐了两个人，如何判断这个状态是不是有效的呢？首先将原状态左移，右移，如果它们的与运算结果为 0，则表明学生左侧和右侧没有人坐。此外，类似地，我们还要保证学生坐在良好的座位上。</p><p><img src="https://pic.leetcode-cn.com/ffc20d9f387c7921139dab9907a03c0a07012c89e0ee01d1291ad626c81f2fc3-p2.png" alt="p2.png"></p><p><em>3. 判断此状态 i 与下一个状态 i+1 的关系</em><br>与步骤 2 类似，将下一行的状态 i+1 分别左移，右移，再与状态 i 作与运算，来判断状态 i 的左上和右上是否有人，从而判断是否可以传递状态。</p><p>如果与运算结果为 0，表示左上或者右上没有人，满足传递状态，这时状态转移方程为 <code>dp[i+1][j] = max(dp[i+1][j], dp[i][k] + count(j))</code>，<code>count(j)</code> 表示 <code>i+1</code> 状态中 1 的数量。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> functools <span class="token keyword">import</span> reduce<span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxStudents</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> seats<span class="token punctuation">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        m<span class="token punctuation">,</span> n <span class="token operator">=</span> len<span class="token punctuation">(</span>seats<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>seats<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 状态数组 dp</span>        <span class="token comment" spellcheck="true"># print(dp)</span>        a <span class="token operator">=</span> <span class="token punctuation">[</span>reduce<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span>y<span class="token punctuation">:</span>x<span class="token operator">|</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>y<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token punctuation">[</span>j <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token keyword">if</span> seats<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'#'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">]</span> # 将 # 设为 <span class="token number">1</span>，当遇到 <span class="token punctuation">.</span> 时与运算结果为 <span class="token number">0</span>，表示可以坐人        <span class="token comment" spellcheck="true"># print(a)</span>        <span class="token keyword">for</span> row <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 倒着遍历</span>            <span class="token keyword">print</span><span class="token punctuation">(</span>row<span class="token punctuation">)</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token operator">not</span> j <span class="token operator">&amp;</span> j<span class="token operator">&lt;&lt;</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token operator">not</span> j<span class="token operator">&amp;</span>j<span class="token operator">>></span><span class="token number">1</span> <span class="token operator">and</span> <span class="token operator">not</span> j <span class="token operator">&amp;</span> a<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># j &amp; a[row]代表该位置可以坐人，j &amp; j&lt;&lt;1 and not j&amp;j>>1 表示该位置左右没人可以坐的</span>                    <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                        <span class="token keyword">if</span> <span class="token operator">not</span> j<span class="token operator">&amp;</span>k<span class="token operator">&lt;&lt;</span><span class="token number">1</span> <span class="token operator">and</span> <span class="token operator">not</span> j<span class="token operator">&amp;</span>k<span class="token operator">>></span><span class="token number">1</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># j状态的左上和右上没有人</span>                            dp<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>row<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> bin<span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">print</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span>        <span class="token keyword">return</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N^2)。</li><li>空间复杂度：O(N^2)。</li></ul><p>如有问题，欢迎讨论~</p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 压缩状态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20. Valid Parentheses</title>
      <link href="/2020/02/08/0020/"/>
      <url>/2020/02/08/0020/</url>
      
        <content type="html"><![CDATA[<h1 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20. Valid Parentheses"></a>20. Valid Parentheses</h1><h3 id="题目描述（难度：简单）"><a href="#题目描述（难度：简单）" class="headerlink" title="题目描述（难度：简单）"></a>题目描述（难度：简单）</h3><p><img src="https://i.loli.net/2020/02/08/25WtL8CEpMkcvKV.png" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>当开始接触题目时，我们会不禁想到如果计算出左括号的数量，和右括号的数量，如果每种括号左右数量相同，会不会就是有效的括号了呢？</p><p>事实上不是的，假如输入是 <code>[{]}</code>，每种括号的左右数量分别相等，但不是有效的括号。这是因为结果还与括号的位置有关。</p><p>仔细分析我们发现，对于有效的括号，它的部分子表达式仍然是有效的括号，比如 <code>{()[()]}</code> 是一个有效的括号，<code>()[{}]</code> 是有效的括号，<code>[()]</code> 也是有效的括号。并且当我们每次删除一个最小的括号对时，我们会逐渐将括号删除完。比如下面的例子。</p><p><img src="https://pic.leetcode-cn.com/030f65021c3566468d87504c8ebb9d55c4aa023b66406d80a5aee787b6b203de-p1.png" alt="p1.png"></p><p>这个思考的过程其实就是栈的实现过程。因此我们考虑使用栈，当遇到匹配的最小括号对时，我们将这对括号从栈中删除（即出栈），如果最后栈为空，那么它是有效的括号，反之不是。</p><p><img src="https://pic.leetcode-cn.com/baa8829ac398e665eb645dca29eadd631e2b337e05022aa5a678e091471a4913-20.gif" alt="20.gif"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isValid</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        dic <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">')'</span><span class="token punctuation">:</span><span class="token string">'('</span><span class="token punctuation">,</span><span class="token string">']'</span><span class="token punctuation">:</span><span class="token string">'['</span><span class="token punctuation">,</span><span class="token string">'}'</span><span class="token punctuation">:</span><span class="token string">'{'</span><span class="token punctuation">}</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> s<span class="token punctuation">:</span>            <span class="token keyword">if</span> stack <span class="token operator">and</span> i <span class="token keyword">in</span> dic<span class="token punctuation">:</span>                <span class="token keyword">if</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> dic<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">else</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>            <span class="token keyword">else</span><span class="token punctuation">:</span> stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token operator">not</span> stack</code></pre><p>代码中我们使用了哈希表来判断是否能够形成括号，从而决定进行入栈操作还是出栈操作。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N)。遍历了一遍字符串。</li><li>空间复杂度：O(N)。最坏情况下，假如输入是 <code>(((((((</code>，栈的大小将是输入字符串的长度。</li></ul><p>如有其他代码欢迎提供<del>如有问题欢迎讨论</del></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17. Letter Combinations of a Phone Number</title>
      <link href="/2020/02/08/0017/"/>
      <url>/2020/02/08/0017/</url>
      
        <content type="html"><![CDATA[<h1 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. Letter Combinations of a Phone Number</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/08/6H4D2QAO9vdgLcW.png" alt=""></p><h3 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h3><p>当题目中出现“所有组合”等类似字眼时，我们第一感觉就要想到用回溯。</p><p>定义函数 <code>backtrack(combination, nextdigit)</code>，当<code>nextdigit</code> 非空时，对于 <code>nextdigit[0]</code> 中的每一个字母 <code>letter</code>，执行回溯 <code>backtrack(combination + letter,nextdigit[1:]</code>，直至 <code>nextdigit</code> 为空。最后将 <code>combination</code> 加入到结果中。</p><p><img src="https://i.loli.net/2020/02/08/1OSwgvtzRC2rpdl.gif" alt="fig 1"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">letterCombinations</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> digits<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> digits<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        phone <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'2'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 <span class="token string">'3'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'d'</span><span class="token punctuation">,</span><span class="token string">'e'</span><span class="token punctuation">,</span><span class="token string">'f'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 <span class="token string">'4'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'g'</span><span class="token punctuation">,</span><span class="token string">'h'</span><span class="token punctuation">,</span><span class="token string">'i'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 <span class="token string">'5'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'j'</span><span class="token punctuation">,</span><span class="token string">'k'</span><span class="token punctuation">,</span><span class="token string">'l'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 <span class="token string">'6'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'m'</span><span class="token punctuation">,</span><span class="token string">'n'</span><span class="token punctuation">,</span><span class="token string">'o'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 <span class="token string">'7'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'p'</span><span class="token punctuation">,</span><span class="token string">'q'</span><span class="token punctuation">,</span><span class="token string">'r'</span><span class="token punctuation">,</span><span class="token string">'s'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 <span class="token string">'8'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'t'</span><span class="token punctuation">,</span><span class="token string">'u'</span><span class="token punctuation">,</span><span class="token string">'v'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                 <span class="token string">'9'</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token string">'w'</span><span class="token punctuation">,</span><span class="token string">'x'</span><span class="token punctuation">,</span><span class="token string">'y'</span><span class="token punctuation">,</span><span class="token string">'z'</span><span class="token punctuation">]</span><span class="token punctuation">}</span>        <span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>conbination<span class="token punctuation">,</span>nextdigit<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> len<span class="token punctuation">(</span>nextdigit<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>conbination<span class="token punctuation">)</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">for</span> letter <span class="token keyword">in</span> phone<span class="token punctuation">[</span>nextdigit<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    backtrack<span class="token punctuation">(</span>conbination <span class="token operator">+</span> letter<span class="token punctuation">,</span>nextdigit<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        backtrack<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span>digits<span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(3^M×4^N)。M 是对应三个字母的数字个数，N 是对应四个字母的数字个数。</li><li>空间复杂度：O(3^M×4^N)。一共要生成 3^M×4^N 个结果。</li></ul><p>（我们看到，一般使用回溯求所有结果的复杂度还是相当大的~）</p><h3 id="方法二：队列"><a href="#方法二：队列" class="headerlink" title="方法二：队列"></a>方法二：队列</h3><p>我们也可以使用队列，先将输入的 <code>digits</code> 中第一个数字对应的每一个字母入队，然后将出队的元素与第二个数字对应的每一个字母组合后入队…直到遍历到 <code>digits</code> 的结尾。最后队列中的元素就是所求结果。</p><p><img src="https://i.loli.net/2020/02/08/y49PUef5QupHBSX.gif" alt="fig 2"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">letterCombinations</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> digits<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>str<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> digits<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        phone <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'abc'</span><span class="token punctuation">,</span><span class="token string">'def'</span><span class="token punctuation">,</span><span class="token string">'ghi'</span><span class="token punctuation">,</span><span class="token string">'jkl'</span><span class="token punctuation">,</span><span class="token string">'mno'</span><span class="token punctuation">,</span><span class="token string">'pqrs'</span><span class="token punctuation">,</span><span class="token string">'tuv'</span><span class="token punctuation">,</span><span class="token string">'wxyz'</span><span class="token punctuation">]</span>        queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">''</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 初始化队列</span>        <span class="token keyword">for</span> digit <span class="token keyword">in</span> digits<span class="token punctuation">:</span>            <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                tmp <span class="token operator">=</span> queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token keyword">for</span> letter <span class="token keyword">in</span> phone<span class="token punctuation">[</span>ord<span class="token punctuation">(</span>digit<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true"># 这里我们不使用 int() 转换字符串，使用ASCII码</span>                    queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp <span class="token operator">+</span> letter<span class="token punctuation">)</span>        <span class="token keyword">return</span> queue</code></pre><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(3^M×4^N)。M 是对应三个字母的数字个数，N 是对应四个字母的数字个数。</li><li>空间复杂度：O(3^M×4^N)。一共要生成 3^M×4^N 个结果。</li></ul><p>欢迎补充其他代码<del>如有问题，欢迎讨论</del></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 回溯算法 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零学 C++：指针总结</title>
      <link href="/2020/02/08/cpp-p04l02/"/>
      <url>/2020/02/08/cpp-p04l02/</url>
      
        <content type="html"><![CDATA[<h1 id="从零学-C-：指针总结"><a href="#从零学-C-：指针总结" class="headerlink" title="从零学 C++：指针总结"></a>从零学 C++：指针总结</h1><blockquote><p>看了几天 C++，没想到那个讲话的老头是 C++ 创始人…</p></blockquote><h3 id="指针是什么？"><a href="#指针是什么？" class="headerlink" title="指针是什么？"></a>指针是什么？</h3><p>C++ 创始人 Bjarne 这样说：</p><p>“Dennis Ritchie 对于 C 的基本机器模型有一个很好的想法。他认为对于内存对象的所有数据序列，可以通过指针来引用他们，这些指针是类型为 so 的机器地址。指针其实是机器地址，它是一段内存大小为 n 的引用。指针在编译的时候与类型关联，以便使人们知道它要指向的是整数，或者字符串等。C++ 采用 C 的内存模型，假如要在指向的整数旁边增加一个整数，那么我们可以将内存中的字段加一或者减一。这就是指针，它是在编译时具有关联类型的机器地址。”</p><h3 id="从代码学指针"><a href="#从代码学指针" class="headerlink" title="从代码学指针"></a>从代码学指针</h3><p>废话不多说，看一段代码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">/*在这个例子中，我们实现了一个函数，这个函数可以计算输入的正弦和余弦值，并返回。其实现过程如下：    导入标准库 iostream    导入 math.h 库以使用三角函数    创建一个具有三个参数的函数：_sin，_cos 和 angle。所有        参数都是双精度类型    该函数的返回类型无效    将输入参数（角度变量除外）声明为双精度类型的指针    创建 main 函数    声明三个双变量：角度，_sin，_cos    要求用户通过cin来输入角度值    调用三角函数（通过引用传递sin和cos变量）    在控制台中打印结果*/</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;cmath></span></span><span class="token keyword">void</span> <span class="token function">trigonometry</span><span class="token punctuation">(</span><span class="token keyword">double</span> angle<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">*</span>_sin<span class="token punctuation">,</span> <span class="token keyword">double</span> <span class="token operator">*</span>_cos<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token operator">*</span>_sin <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">sin</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">*</span>_cos <span class="token operator">=</span> std<span class="token operator">::</span><span class="token function">cos</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> angle<span class="token punctuation">,</span> _sin<span class="token punctuation">,</span> _cos<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Write angle in radians:"</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cin <span class="token operator">>></span> angle<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">" Trigonometry values are: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token function">trigonometry</span><span class="token punctuation">(</span>angle<span class="token punctuation">,</span> <span class="token operator">&amp;</span>_sin<span class="token punctuation">,</span> <span class="token operator">&amp;</span>_cos<span class="token punctuation">)</span><span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Sine is: "</span><span class="token operator">&lt;&lt;</span> _sin <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Cosine is: "</span><span class="token operator">&lt;&lt;</span> _cos <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><ul><li>从零学 C++：链表总结</li></ul><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15. 3Sum</title>
      <link href="/2020/02/07/0015/"/>
      <url>/2020/02/07/0015/</url>
      
        <content type="html"><![CDATA[<h1 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15. 3Sum"></a>15. 3Sum</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/07/NqMmn6TCGHwb2iA.png" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>1. 排序</strong>（$O(NlogN)$）<br>为什么要排序呢？我想是不是这样：</p><ul><li>排序后相同的数会挨在一起，所以方便接下来的操作来避免重复；</li><li>右边的数比左边的大，方便比较。</li></ul><p><strong>2. 遍历</strong>（$O(N^2)$）<br>我们定义当前下标 <code>k</code>，<code>i, j</code> 分别位于 <code>k + 1, len(nums) - 1</code>的位置。若 <code>k = 1</code>，如下图所示：</p><p><img src="https://pic.leetcode-cn.com/26f5fa65fe52bf8b7c2397f2a9ce4efe0fbb29b939ad411c938e87b06022a6b9-file_1581062450524" alt="1.png"></p><p>从左到右遍历，对于每个 <code>k</code> 值：</p><ul><li>如果三数之和大于 <code>0</code>，<code>j</code> 左移会使得和减小，甚至等于 <code>0</code>，故 <code>j</code> 左移；</li><li>如果三数之和小于 <code>0</code>，<code>i</code> 右移会使得和增大，甚至等于 <code>0</code>，故 <code>i</code> 右移；</li><li>如果三数之和等于 <code>0</code>，将 <code>[nums[i],nums[j],nums[k]]</code> 加入到结果中，<code>i</code> 右移，<code>j</code> 左移，寻找下一组可能结果。</li></ul><p>移动的过程中，如果碰到的数与前一个数相同，我们跳过本次循环，避免结果重复！</p><p><img src="https://i.loli.net/2020/02/07/sC1pl5etox6B9fM.gif" alt="fig 1"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">threeSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span> <span class="token keyword">break</span> <span class="token comment" spellcheck="true"># k后面的数肯定大于零，跳出循环</span>            <span class="token keyword">if</span> k <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token keyword">continue</span>             i<span class="token punctuation">,</span> j <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">while</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                    i <span class="token operator">+=</span> <span class="token number">1</span>                    j <span class="token operator">-=</span> <span class="token number">1</span>                    <span class="token keyword">while</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">and</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>i <span class="token operator">+=</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># 相同的数跳过</span>                    <span class="token keyword">while</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">and</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>j <span class="token operator">-=</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># 相同的数跳过</span>                <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>                    i <span class="token operator">+=</span> <span class="token number">1</span>                    <span class="token keyword">while</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">and</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>i <span class="token operator">+=</span> <span class="token number">1</span>                 <span class="token keyword">else</span><span class="token punctuation">:</span>                    j <span class="token operator">-=</span> <span class="token number">1</span>                    <span class="token keyword">while</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">and</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>j <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(N^2)$。</li><li>空间复杂度：$O(1)$。<h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3></li></ul><p>有比时间复杂度为 $O(n^2)$ 更低的算法吗？事实上是有的，比如 <a href="https://en.wikipedia.org/wiki/3SUM" target="_blank" rel="noopener">维基百科</a> 中的 $O(n^2/(log n/ log log n)^2/3)$ 等。但是对于刷题人来讲，掌握 $O(n^2)$ 的解法我觉得已经足够。😄</p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18. 4Sum</title>
      <link href="/2020/02/07/0018/"/>
      <url>/2020/02/07/0018/</url>
      
        <content type="html"><![CDATA[<h1 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18. 4Sum"></a>18. 4Sum</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/08/Af6pLxDGOdIwRjg.png" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>本题是三数之和的进阶题目，强烈建议您先看三数之和的 <a href="https://leetcode-cn.com/problems/3sum/solution/pai-xu-shuang-zhi-zhen-tu-jie-by-ml-zimingmeng/" target="_blank" rel="noopener">解题思路</a>，看过之后再来看本题目，思路也就非常清晰了。</p><p>具体来说，对比三数之和最快的双指针方法，我们只需在外层在嵌套一层循环即可。这样时间复杂度将从 $O(N^2)$ 变为 $O(N^3)$。</p><h3 id="有没有更快的解法"><a href="#有没有更快的解法" class="headerlink" title="有没有更快的解法"></a>有没有更快的解法</h3><p><a href="https://en.wikipedia.org/wiki/3SUM" target="_blank" rel="noopener">维基百科</a> 中提到了三数之和小于 $O(N^2)$ 的时间复杂度的解法，因此四数之和的时间复杂度理论上可以小于 $O(N^3)$，但是我认为有些“超纲了”，没必要掌握。</p><p>我们仍然可以在 $O(N^3)$ 的时间复杂度内通过增加条件判断使得速度得到很大提升。主要考虑以下几点：</p><ul><li>指针依次是 <code>p,k,i,j</code>，如果 <code>nums[p] + 3 * nums[p + 1] &gt; target</code>，因为 <code>nums</code> 按升序排列，所以之后的数肯定都大于 <code>target</code> ，直接 <code>break</code>；</li><li>如果 <code>nums[p] + 3 * nums[-1] &lt; target</code>，那么当前的 <code>nums[p]</code> 加其余三个数一定小于 <code>target</code>，故 <code>p</code> 直接下一位即可，<code>continue</code>；</li><li><code>k</code> 和 <code>p</code> 判断完全一样，只是将 <code>3</code> 变成了 <code>2</code>，<code>target</code> 变成了 <code>target - nums[p]</code>。</li></ul><p>同样地，为了避免结果重复，某个指针遇到相同的数需要直接跳过，这与三数之和是一样的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">fourSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        nums<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        p <span class="token operator">=</span> <span class="token number">0</span> <span class="token comment" spellcheck="true"># p, k, i, j</span>        <span class="token keyword">while</span> p <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">3</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 文中提到的两个条件，可以直接跳过</span>            <span class="token keyword">if</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">:</span> <span class="token keyword">break</span>              <span class="token keyword">if</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                           <span class="token keyword">while</span> p <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">4</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> p <span class="token operator">+=</span> <span class="token number">1</span>                p <span class="token operator">+=</span> <span class="token number">1</span>                <span class="token keyword">continue</span>            k <span class="token operator">=</span> p <span class="token operator">+</span> <span class="token number">1</span>            <span class="token keyword">while</span> k <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true"># k 和 p 的判断是一样的</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">:</span> <span class="token keyword">break</span>                <span class="token keyword">if</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                     <span class="token keyword">while</span> k <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">3</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                        k <span class="token operator">+=</span> <span class="token number">1</span>                    k <span class="token operator">+=</span> <span class="token number">1</span>                    <span class="token keyword">continue</span>                i <span class="token operator">=</span> k <span class="token operator">+</span> <span class="token number">1</span>                j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span>                new_target <span class="token operator">=</span> target <span class="token operator">-</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span>                <span class="token keyword">while</span> i <span class="token operator">&lt;</span> j<span class="token punctuation">:</span>                    <span class="token keyword">if</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> new_target<span class="token punctuation">:</span> j <span class="token operator">-=</span> <span class="token number">1</span>                    <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> new_target<span class="token punctuation">:</span> i <span class="token operator">+=</span> <span class="token number">1</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                        i <span class="token operator">+=</span> <span class="token number">1</span>                        j <span class="token operator">-=</span> <span class="token number">1</span>                        <span class="token keyword">while</span> i <span class="token operator">&lt;</span> j <span class="token operator">and</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> i <span class="token operator">+=</span> <span class="token number">1</span> <span class="token comment" spellcheck="true"># 避免结果重复</span>                        <span class="token keyword">while</span> i <span class="token operator">&lt;</span> j <span class="token operator">and</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> j <span class="token operator">-=</span> <span class="token number">1</span> <span class="token comment" spellcheck="true"># 避免结果重复</span>                <span class="token keyword">while</span> k <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">3</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> k <span class="token operator">+=</span> <span class="token number">1</span>                k <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">while</span> p <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">4</span> <span class="token operator">and</span> nums<span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span> p <span class="token operator">+=</span> <span class="token number">1</span>            p <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N^3)。</li><li>空间复杂度：O(1)。</li></ul><p>如有问题，欢迎讨论~</p><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ul><li><a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">1.两数之和</a></li><li><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15.三数之和</a></li><li><a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener">454. 四数相加 II</a></li></ul><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12. Integer to Roman</title>
      <link href="/2020/02/07/0012/"/>
      <url>/2020/02/07/0012/</url>
      
        <content type="html"><![CDATA[<h1 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="12. Integer to Roman"></a>12. Integer to Roman</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/07/2uUAOKCNxHLEp9n.png" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们每次尽量使用最大的数来表示，这个方法符合贪心法则。比如对于 1994 这个数，如果我们每次尽量用最大的数来表示，依次选 1000，900，90，4，会得到正确结果 <code>MCMXCIV</code>。</p><p>所以，我们将哈希表按照从大到小的顺序排列，然后遍历哈希表，直到表示完整个输入。</p><p><img src="https://i.loli.net/2020/02/07/HWvbXJs8yGtSq6T.gif" alt="fig 1"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">intToRoman</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> num<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 使用哈希表，按照从大到小顺序排列</span>        hashmap <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1000</span><span class="token punctuation">:</span><span class="token string">'M'</span><span class="token punctuation">,</span> <span class="token number">900</span><span class="token punctuation">:</span><span class="token string">'CM'</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">:</span><span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token number">400</span><span class="token punctuation">:</span><span class="token string">'CD'</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">:</span><span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">:</span><span class="token string">'XC'</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">:</span><span class="token string">'L'</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">:</span><span class="token string">'XL'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">:</span><span class="token string">'X'</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">:</span><span class="token string">'IX'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">:</span><span class="token string">'V'</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">:</span><span class="token string">'IV'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">:</span><span class="token string">'I'</span><span class="token punctuation">}</span>        res <span class="token operator">=</span> <span class="token string">''</span>        <span class="token keyword">for</span> key <span class="token keyword">in</span> hashmap<span class="token punctuation">:</span>            <span class="token keyword">if</span> num <span class="token operator">//</span> key <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span>                count <span class="token operator">=</span> num <span class="token operator">//</span> key  <span class="token comment" spellcheck="true"># 比如输入4000，count 为 4</span>                res <span class="token operator">+=</span> hashmap<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">*</span> count                 num <span class="token operator">%=</span> key        <span class="token keyword">return</span> res</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(1)$。最坏条件下，循环的次数为哈希表的长度。</li><li>空间复杂度：$O(1)$。</li></ul><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13. Roman to Integer</title>
      <link href="/2020/02/07/0013/"/>
      <url>/2020/02/07/0013/</url>
      
        <content type="html"><![CDATA[<h1 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13. Roman to Integer"></a>13. Roman to Integer</h1><h3 id="题目描述（难度：简单）"><a href="#题目描述（难度：简单）" class="headerlink" title="题目描述（难度：简单）"></a>题目描述（难度：简单）</h3><p><img src="https://i.loli.net/2020/02/07/h29b5oQBwxz1GRZ.png" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过观察我们发现，<strong>只有在遇到特殊情况时，两个字符中左边的字符小于右边的字符，且等于右边的字符代表的数减左边字符代表的数</strong>。 比如 <code>CM</code> 等于 $1000 - 100$，<code>XC</code> 等于 $100 - 10$…</p><p>因此，我们将 <code>字符：数值</code> 存在 <code>Roman2Int</code> 的哈希表中。然后从左到右遍历每个字符，如果 <code>s[i] &lt; s[i+1]</code>，就将结果减去 <code>s[i]</code> 代表的数字；否则，将结果加上 <code>s[i]</code> 代表的数字。</p><p><img src="https://i.loli.net/2020/02/07/nOFuzgEqVbNJ6iL.gif" alt="fig 1"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">romanToInt</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        Roman2Int <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'I'</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">'V'</span><span class="token punctuation">:</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">'X'</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">'L'</span><span class="token punctuation">:</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token string">'C'</span><span class="token punctuation">:</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token string">'D'</span><span class="token punctuation">:</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token string">'M'</span><span class="token punctuation">:</span><span class="token number">1000</span><span class="token punctuation">}</span>        Int <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> index <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> Roman2Int<span class="token punctuation">[</span>s<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> Roman2Int<span class="token punctuation">[</span>s<span class="token punctuation">[</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                Int <span class="token operator">-=</span> Roman2Int<span class="token punctuation">[</span>s<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                Int <span class="token operator">+=</span> Roman2Int<span class="token punctuation">[</span>s<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">]</span>        <span class="token keyword">return</span> Int <span class="token operator">+</span> Roman2Int<span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span></code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(N)$。遍历了一遍数组。</li><li>空间复杂度：$O(1)$。使用了 <code>Int</code>。</li></ul><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>42. Trapping Rain Water</title>
      <link href="/2020/02/06/0042/"/>
      <url>/2020/02/06/0042/</url>
      
        <content type="html"><![CDATA[<h1 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42. Trapping Rain Water"></a>42. Trapping Rain Water</h1><h3 id="题目描述（难度：困难）"><a href="#题目描述（难度：困难）" class="headerlink" title="题目描述（难度：困难）"></a>题目描述（难度：困难）</h3><p><img src="https://i.loli.net/2020/02/05/RpYfBHiJtQVjkcT.png" alt=""></p><h3 id="方法一：暴力"><a href="#方法一：暴力" class="headerlink" title="方法一：暴力"></a>方法一：暴力</h3><p>一开始拿到题目之后可能会有些手足无措，我们从最原始的暴力解法开始思考，对于每个下标 i，我们计算它上方可以接多少雨水，然后将所有下标上的雨水加起来即可。</p><p><img src="https://i.loli.net/2020/02/06/Kfp3ARoSmc98Zud.png" alt="fig 1"></p><p>具体来说，如图我们假设输入为 <code>[0,1,0,2]</code>，凭感觉，我们得到接完雨水后的结果如右图。可以看到，只有下标 2 的上方可以接到雨水，其他地方的水会向两边“流掉”，所以无法接到水。</p><p>为什么是这样呢？首先看下标 1 ，它左边最高的柱子是下标 0 ，右边最高的柱子是下标 3 ，因为这两个柱子的较小值比下标 1 要低，所以下标 1 的上方没有水。相反，我们看下标 2，它左边最高的柱子是下标 1 ，右边最高的柱子是下标 3 ，这两个柱子较矮的是下标 1 ，它比下标 2 本身要高，所以下标 2 可以接到水，接的水就是高度差。</p><p>因此，我们遍历每个下标，寻找它左边和右边最高的柱子，判断是否可以接到水，将可接水的结果累加即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>Python3 代码如下：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">trap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        ans <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            max_left<span class="token punctuation">,</span> max_right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span>            <span class="token comment" spellcheck="true"># 寻找 max_left</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>                max_left <span class="token operator">=</span> max<span class="token punctuation">(</span>max_left<span class="token punctuation">,</span>height<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 寻找 max_right</span>            <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span>len<span class="token punctuation">(</span>height<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                max_right <span class="token operator">=</span> max<span class="token punctuation">(</span>max_right<span class="token punctuation">,</span>height<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> min<span class="token punctuation">(</span>max_left<span class="token punctuation">,</span>max_right<span class="token punctuation">)</span> <span class="token operator">></span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                ans <span class="token operator">+=</span> min<span class="token punctuation">(</span>max_left<span class="token punctuation">,</span>max_right<span class="token punctuation">)</span> <span class="token operator">-</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> ans</code></pre><p>C++ 代码如下：</p><pre class=" language-C++"><code class="language-C++">class Solution {public:    int trap(vector<int>& height) {        int ans = 0;        int n = height.size();        int maxleft;        int maxright;        for (int i = 0;i < n;i++){            maxleft = maxright = 0;            for (int j = 0;j < i;j++){                maxleft = max(maxleft,height[j]);            }            for (int k = i;k<n;k++){                maxright = max(maxright,height[k]);            }            if (min(maxleft,maxright) > height[i]){                ans += min(maxleft,maxright) - height[i];            }        }        return ans;    }};</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N^2)。最坏情况下，我们对于每个下标，都要向左和向右遍历直到两端，复杂度是 N 的平方。</li><li>空间复杂度：O(1)。使用了有限的 <code>n</code>, <code>ans</code>, <code>maxleft</code>, <code>maxright</code>。</li></ul><h3 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><p>我们发现在寻找每个下标的左边和右边最高的柱子时，会对柱子进行反复搜索导致复杂度降低，假如我们使用两个数组 <code>maxleft</code> 和 <code>maxright</code>，<code>maxleft[i]</code> 表示下标 <code>i</code> 左边最高柱子的高度，<code>maxright[i]</code> 表示下标 <code>i</code> 右边最高柱子的高度，很明显，我们只需要一趟遍历就可以得到结果。这样由于避免了重复计算，时间复杂度会降低到 O(N)。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>Python3 代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">trap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 边界条件</span>        <span class="token keyword">if</span> <span class="token operator">not</span> height<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>height<span class="token punctuation">)</span>        maxleft <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        maxright <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        ans <span class="token operator">=</span> <span class="token number">0</span>        <span class="token comment" spellcheck="true"># 初始化</span>        maxleft<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>        maxright<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">=</span> height<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 设置备忘录，分别存储左边和右边最高的柱子高度</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            maxleft<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>maxleft<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            maxright<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>height<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>maxright<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># 一趟遍历，比较每个位置可以存储多少水</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> min<span class="token punctuation">(</span>maxleft<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>maxright<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">></span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>                ans <span class="token operator">+=</span> min<span class="token punctuation">(</span>maxleft<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>maxright<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> height<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">return</span> ans</code></pre><p>C++ 代码：</p><pre class=" language-C++"><code class="language-C++">class Solution {public:    int trap(vector<int>& height) {        if (height.size() == 0){            return 0;        }        int n = height.size();        vector<int> maxleft (n);        vector<int> maxright (n);        int ans = 0;        maxleft[0] = height[0];        maxright[n-1] = height[n-1];        for (int i=1;i<n;i++){            maxleft[i] = max(height[i], maxleft[i-1]);        }        for (int j=n-2;j>-1;j--){            maxright[j] = max(height[j],maxright[j+1]);        }        for (int k=0;k<n;k++){            if (min(maxleft[k],maxright[k]) > height[k]){                ans += min(maxleft[k],maxright[k]) - height[k];            }         }        return ans;    }};</code></pre><p>由于使用了数组，我们的空间复杂度会增加到 O(N),如何能把空间复杂度也降低呢？我们可以使用双指针法。</p><h3 id="方法三：双指针法"><a href="#方法三：双指针法" class="headerlink" title="方法三：双指针法"></a>方法三：双指针法</h3><p>双指针法就是将上边的一个下标 <code>i</code>，变为两个下标 <code>left</code>，<code>right</code>，分别位于输入数组的两端。向中间移动时，边移动边计算。</p><p>除此之外，我们使用 <code>maxleft</code> 作为 <code>0...left</code> 的最大值，<code>maxright</code> 作为 <code>right...结尾</code> 的最大值。<br><img src="https://i.loli.net/2020/02/06/vghCOkoyV7qxlw3.gif" alt="fig 2"></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><p>Python 代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">trap</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 边界条件</span>        <span class="token keyword">if</span> <span class="token operator">not</span> height<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token number">0</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>height<span class="token punctuation">)</span>        left<span class="token punctuation">,</span>right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span>  <span class="token comment" spellcheck="true"># 分别位于输入数组的两端</span>        maxleft<span class="token punctuation">,</span>maxright <span class="token operator">=</span> height<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>        ans <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">while</span> left <span class="token operator">&lt;=</span> right<span class="token punctuation">:</span>            maxleft <span class="token operator">=</span> max<span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span>maxleft<span class="token punctuation">)</span>            maxright <span class="token operator">=</span> max<span class="token punctuation">(</span>height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">,</span>maxright<span class="token punctuation">)</span>            <span class="token keyword">if</span> maxleft <span class="token operator">&lt;</span> maxright<span class="token punctuation">:</span>                ans <span class="token operator">+=</span> maxleft <span class="token operator">-</span> height<span class="token punctuation">[</span>left<span class="token punctuation">]</span>                left <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                ans <span class="token operator">+=</span> maxright <span class="token operator">-</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span>                right <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> ans</code></pre><p>C++ 代码：</p><pre class=" language-C++"><code class="language-C++">class Solution {public:    int trap(vector<int>& height) {        if(height.size() == 0){            return 0;        }        int n = height.size();        int left = 0;        int right = n - 1;        int maxleft = height[0];        int maxright = height[n-1];        int ans = 0;        while (left <= right){            maxleft = max(height[left],maxleft);            maxright = max(height[right],maxright);            if(maxleft < maxright){                ans += maxleft - height[left];                left++;            }            else{                ans += maxright - height[right];                right--;            }        }        return ans;    }};</code></pre><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N)。遍历了一遍数组。</li><li>空间复杂度：O(1)。使用了有限的 <code>left</code>, <code>right</code>, <code>ans</code>, <code>maxleft</code>, <code>maxright</code>。</li></ul><p>如有疑问，欢迎批评指正~</p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. Container With Most Water</title>
      <link href="/2020/02/05/0011/"/>
      <url>/2020/02/05/0011/</url>
      
        <content type="html"><![CDATA[<h1 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11. Container With Most Water"></a>11. Container With Most Water</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/05/f75Z8zFqr96ipAw.png" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><a href="https://leetcode-cn.com/problems/container-with-most-water/solution/sheng-zui-duo-shui-de-rong-qi-by-leetcode/" target="_blank" rel="noopener">可以参考官方题解的动图</a>，思路很简单，设置两个指针 <code>start</code> 和 <code>end</code> 分别位于容器两端，当 <code>start &lt; end</code> 时，每次将高度较矮的指针向内移动，同时更新最大面积。（这个的证明可以用反证法，官方题解可以找到）通俗来讲，因为每次向内移动时，距离就减小，只有移动高度较矮的那个，才有机会碰到高度更高的使得面积增大。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxArea</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> height<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        ans <span class="token operator">=</span> float<span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span>        start<span class="token punctuation">,</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>height<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>        <span class="token keyword">while</span> start <span class="token operator">&lt;</span> end<span class="token punctuation">:</span>            ans <span class="token operator">=</span> max<span class="token punctuation">(</span>ans<span class="token punctuation">,</span>min<span class="token punctuation">(</span>height<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">,</span>height<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> height<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> height<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">:</span>                start <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                end <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> ans</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(1)</li></ul><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>有很多题如果只想到了 O(N^2) 的解法往往是不够的，比如这道题利用双指针可以优化到 O(N)。这道题二刷的时候做得确实比开始时候要轻松一些~加油！</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10. Regular Expression Matching</title>
      <link href="/2020/02/05/0010/"/>
      <url>/2020/02/05/0010/</url>
      
        <content type="html"><![CDATA[<h1 id="10-Regular-Expression-Matching"><a href="#10-Regular-Expression-Matching" class="headerlink" title="10. Regular Expression Matching"></a>10. Regular Expression Matching</h1><h3 id="题目描述（难度：困难）"><a href="#题目描述（难度：困难）" class="headerlink" title="题目描述（难度：困难）"></a>题目描述（难度：困难）</h3><p><img src="https://i.loli.net/2020/02/05/OHLFRpZn8ybgW73.png" alt=""></p><h3 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h3><p>首先，我们考虑只有’.’的情况。这种情况会很简单：我们只需要从左到右依次判断 <code>s[i]</code> 和 <code>p[i]</code> 是否匹配。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>s<span class="token punctuation">:</span>str<span class="token punctuation">,</span> p<span class="token punctuation">:</span>str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>    <span class="token keyword">if</span> <span class="token operator">not</span> p<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">not</span> s <span class="token comment" spellcheck="true"># 边界条件</span>    first_match <span class="token operator">=</span> s <span class="token operator">and</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">in</span> <span class="token punctuation">{</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'.'</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true"># 比较第一个字符是否匹配</span>    <span class="token keyword">return</span> first_match <span class="token operator">and</span> self<span class="token punctuation">.</span>isMatch<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>如果有星号，它会出现在 <code>p[1]</code> 的位置，这时有两种情况：</p><ul><li>星号代表匹配 0 个前面的元素。如 <code>'##'</code> 和 <code>a*##</code>，这时我们直接忽略 p 的 <code>a*</code>，比较 <code>##</code> 和 <code>##</code>；</li><li>星号代表匹配一个或多个前面的元素。如 <code>aaab</code> 和 <code>a*b</code>，这时我们将忽略 s 的第一个元素，比较 <code>aab</code> 和 <code>a*b</code>。</li></ul><p>以上任一情况忽略掉元素进行比较时，剩下的如果匹配，我们认为 s 和 p 是匹配的。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> p<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> p<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">not</span> s        <span class="token comment" spellcheck="true"># 第一个字母是否匹配</span>        first_match <span class="token operator">=</span> s <span class="token operator">and</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">in</span> <span class="token punctuation">{</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'.'</span><span class="token punctuation">}</span>        <span class="token comment" spellcheck="true"># 如果 p 第二个字母是 *</span>        <span class="token keyword">if</span> len<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span> <span class="token operator">and</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"*"</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> self<span class="token punctuation">.</span>isMatch<span class="token punctuation">(</span>s<span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> \            first_match <span class="token operator">and</span> self<span class="token punctuation">.</span>isMatch<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> first_match <span class="token operator">and</span> self<span class="token punctuation">.</span>isMatch<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h3 id="方法二：动态规划"><a href="#方法二：动态规划" class="headerlink" title="方法二：动态规划"></a>方法二：动态规划</h3><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p>很容易想到，<code>dp[i][j]</code> 表示的状态是 s 的前 i 项和 p 的前 j 项是否匹配。</p><h4 id="转移方程"><a href="#转移方程" class="headerlink" title="转移方程"></a>转移方程</h4><p>现在如果已知了 <code>dp[i-1][j-1]</code> 的状态，我们该如何确定 <code>dp[i][j]</code> 的状态呢？我们可以分三种情况讨论，其中，前两种情况考虑了所有能匹配的情况，剩下的就是不能匹配的情况了：</p><ul><li><p><code>s[i] == p[j] or p[j] == '.'</code>：比如 ab<strong>b</strong> 和 ab<strong>b</strong>，或者 ab<strong>b</strong> 和 ab. ，很容易得到 <code>dp[i][j] = dp[i-1][j-1] = True</code>。因为 ab 和 ab 是匹配的，如果后面分别加一个 b，或者 s 加一个 b 而 p 加一个 . ，仍然是匹配的。</p></li><li><p><code>p[j] == '*'</code>：当 <code>p[j]</code> 为星号时，由于星号与前面的字符相关，因此我们比较星号前面的字符 <code>p[j-1]</code> 和 <code>s[i]</code> 的关系。根据星号前面的字符与 <code>s[i]</code> 是否相等，又可分为以下两种情况：</p><ul><li><code>p[j-1] != s[i]</code>：如果星号前一个字符匹配不上，星号匹配了 0 次，应忽略这两个字符，看 <code>p[j-2]</code> 和 <code>s[i]</code> 是否匹配。 这时 <code>dp[i][j] = dp[i][j-2]</code>。</li><li><code>p[j-1] == s[i] or p[j-1] == '.'</code>:星号前面的字符可以与 <code>s[i]</code> 匹配，这种情况下，星号可能匹配了前面的字符的 0 个，也可能匹配了前面字符的多个，当匹配 0 个时，如 a<strong>b</strong> 和 ab<strong>b*</strong>，或者 a<strong>b</strong> 和 ab.* ，这时我们需要去掉 p 中的 <code>b*</code> 或 <code>.*</code> 后进行比较，即 <code>dp[i][j] = dp[i][j-2]</code>；当匹配多个时，如 abb<strong>b</strong> 和 a<strong>b*</strong>，或者 abb<strong>b</strong> 和 a.*，我们需要将 <code>s[i]</code> 前面的与 p 重新比较，即 <code>dp[i][j] = dp[i-1][j]</code></li></ul></li><li><p>其他情况：以上两种情况把能匹配的都考虑全面了，所以其他情况为不匹配，即 <code>dp[i][j] = False</code></p></li></ul><h4 id="将以上进行归纳得到状态转移方程"><a href="#将以上进行归纳得到状态转移方程" class="headerlink" title="将以上进行归纳得到状态转移方程"></a>将以上进行归纳得到状态转移方程</h4><p><img src="https://i.loli.net/2020/02/05/37IrNXSBDTR2nd1.png" alt="fig 1"></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> p<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 边界条件，考虑 s 或 p 分别为空的情况</span>        <span class="token keyword">if</span> <span class="token operator">not</span> p<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token operator">not</span> s        <span class="token keyword">if</span> <span class="token operator">not</span> s <span class="token operator">and</span> len<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>        m<span class="token punctuation">,</span> n <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token boolean">False</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 初始状态</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token keyword">for</span> c <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>            j <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">if</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">:</span>                dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span>        <span class="token keyword">for</span> r <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>            i <span class="token operator">=</span> r <span class="token operator">-</span> <span class="token number">1</span>            <span class="token keyword">for</span> c <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>                j <span class="token operator">=</span> c <span class="token operator">-</span> <span class="token number">1</span>                <span class="token keyword">if</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">or</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span>                <span class="token keyword">elif</span> p<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'*'</span><span class="token punctuation">:</span>       <span class="token comment" spellcheck="true"># ‘*’前面的字符匹配s[i] 或者为'.'</span>                    <span class="token keyword">if</span> p<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">or</span> p<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'.'</span><span class="token punctuation">:</span>                        dp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>r <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">or</span> dp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                       <span class="token comment" spellcheck="true"># ‘*’匹配了0次前面的字符</span>                        dp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">]</span>                 <span class="token keyword">else</span><span class="token punctuation">:</span>                    dp<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">False</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span></code></pre><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>递归的方法思路比较简单，动态规划中处理星号和点的时候，需要将细节考虑清楚，这样写代码的时候就容易了~加油！</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Python3 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 回溯算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>55. Jump Game</title>
      <link href="/2020/02/04/0055/"/>
      <url>/2020/02/04/0055/</url>
      
        <content type="html"><![CDATA[<h1 id="1344-Jump-Game-V"><a href="#1344-Jump-Game-V" class="headerlink" title="1344. Jump Game V"></a>1344. Jump Game V</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/04/cAE6rgJXDdsLm1B.png" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>我们设定初始值 <code>max_i</code> 为当前可跳的最远位置，遍历一遍数组，维护 <code>max_i</code>。遍历结束后，如果 <code>max_i &gt;= len(nums) - 1</code>，这时说明能够到达最后位置,返回 <code>True</code>，否则返回 <code>False</code>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>Python3</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">canJump</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 初始化能到达的最远位置</span>        max_i <span class="token operator">=</span> <span class="token number">0</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> num <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> max_i <span class="token operator">>=</span> i <span class="token operator">and</span> i <span class="token operator">+</span> num <span class="token operator">></span> max_i<span class="token punctuation">:</span>                max_i <span class="token operator">=</span> i <span class="token operator">+</span> num        <span class="token keyword">return</span> max_i <span class="token operator">>=</span> i <span class="token comment" spellcheck="true"># >= 是因为可能会跳出界</span></code></pre><p>C++</p><pre class=" language-C++"><code class="language-C++">class Solution {public:    bool canJump(vector<int>& nums) {        int max_i = 0;        for(int i = 0; i<nums.size();i++){            if(max_i >= i && i + nums[i] > max_i){                max_i = i + nums[i];            }        }        return max_i >= nums.size() - 1;    }};</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N)。</li><li>空间复杂度：O(1)。</li></ul><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ul><li><a href="//0045.md">跳跃游戏 Ⅱ</a></li><li><a href="//1306.md">跳跃游戏 Ⅲ</a></li><li>跳跃游戏 Ⅳ</li><li>跳跃游戏 Ⅴ</li></ul><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>动态规划的题目比较难，我们需要吃透几个题目，慢慢去体会~加油！</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心算法 </tag>
            
            <tag> LeetCode </tag>
            
            <tag> Python3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1344. Jump Game V</title>
      <link href="/2020/02/04/1344/"/>
      <url>/2020/02/04/1344/</url>
      
        <content type="html"><![CDATA[<h1 id="1344-Jump-Game-V"><a href="#1344-Jump-Game-V" class="headerlink" title="1344. Jump Game V"></a>1344. Jump Game V</h1><h3 id="题目描述（难度：困难）"><a href="#题目描述（难度：困难）" class="headerlink" title="题目描述（难度：困难）"></a>题目描述（难度：困难）</h3><p><img src="https://i.loli.net/2020/02/04/OnIFXgYorURdW6s.png" alt=""></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>我们记录每个下标 <code>i</code> 可以最多访问的下标个数，返回最大值就行了。</p><p>如何记录每个下标的最多访问个数呢？我们使用一维动态规划数组 <code>dp</code> 。<strong>dp[i] 表示下标 i 的最多可访问次数</strong>，我们按照高度从低到高的顺序遍历每个下标，<strong>在可跳范围内</strong>，我们更新 <code>dp[i]</code> 的值。状态方程为 $dp[i] = max(dp[idx] + 1, cur)$ ,建议查看 <a href="https://leetcode-cn.com/problems/jump-game-v/solution/yi-wei-dong-tai-gui-hua-tu-jie-python3-by-ml-zimin/" target="_blank" rel="noopener">原题解动图</a> 理解状态方程。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">maxJumps</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> d<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>        L <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>        L <span class="token operator">=</span> sorted<span class="token punctuation">(</span>L<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>        dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> n        <span class="token keyword">for</span> h<span class="token punctuation">,</span> i <span class="token keyword">in</span> L<span class="token punctuation">:</span>            cur <span class="token operator">=</span> <span class="token number">1</span>            <span class="token comment" spellcheck="true"># 向左跳</span>            <span class="token keyword">for</span> idx <span class="token keyword">in</span> range<span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> max<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">-</span> d<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> arr<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">>=</span> h<span class="token punctuation">:</span>                    <span class="token keyword">break</span>                cur <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>cur<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># 向右跳</span>            <span class="token keyword">for</span> idx <span class="token keyword">in</span> range<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> min<span class="token punctuation">(</span>n<span class="token punctuation">,</span> i <span class="token operator">+</span> d <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>                <span class="token keyword">if</span> arr<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">>=</span> h<span class="token punctuation">:</span>                    <span class="token keyword">break</span>                cur <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> cur<span class="token punctuation">)</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> cur        <span class="token keyword">return</span><span class="token punctuation">(</span>max<span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(NlogN)。我们遍历了一遍数组，复杂度为 O(N)，再最坏条件下，d = N，对于每个下标的时间复杂度为 O(logN)，因此时间复杂度为 O(NlogN)。</li><li>空间复杂度：O(N)。使用了 <code>L</code> 和 <code>dp</code>。</li></ul><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ul><li><a href="//0045.md">跳跃游戏 Ⅱ</a></li><li><a href="//1306.md">跳跃游戏 Ⅲ</a></li><li>跳跃游戏 Ⅳ</li><li>跳跃游戏 Ⅴ</li></ul><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>动态规划的题目比较难，我们需要吃透几个题目，慢慢去体会~加油！</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Python3 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>240. Search a 2D Matrix II</title>
      <link href="/2020/02/04/0240/"/>
      <url>/2020/02/04/0240/</url>
      
        <content type="html"><![CDATA[<h1 id="240-Search-a-2D-Matrix-II"><a href="#240-Search-a-2D-Matrix-II" class="headerlink" title="240. Search a 2D Matrix II"></a>240. Search a 2D Matrix II</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/06/gVxYfNpzOJZ84jB.png" alt=""><br>解题思路<br>我们从左下角开始遍历，当该值小于 target 值时，向右搜索；大于 target 值时，向上搜索。如果找到 target 则返回 True，否则返回 False。</p><p><img src="https://i.loli.net/2020/02/06/6RJQ1LcpszHojAy.gif" alt="fig 1"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>python 代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># array 二维列表</span>    <span class="token keyword">def</span> <span class="token function">Find</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> target<span class="token punctuation">,</span> array<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> array<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">False</span>        m<span class="token punctuation">,</span> n <span class="token operator">=</span> len<span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        row<span class="token punctuation">,</span> col <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span>        <span class="token keyword">while</span> row <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> col <span class="token operator">&lt;</span> n<span class="token punctuation">:</span>            <span class="token keyword">if</span> array<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">:</span>                col <span class="token operator">+=</span> <span class="token number">1</span>            <span class="token keyword">elif</span> array<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">:</span>                row <span class="token operator">-=</span> <span class="token number">1</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token boolean">True</span>        <span class="token keyword">return</span> <span class="token boolean">False</span></code></pre><p>C++ 代码：</p><pre class=" language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">bool</span> <span class="token function">Find</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> array<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> row <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>row <span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> col <span class="token operator">&lt;</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>                col <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>                row <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(m+n)。m 和 n 分别为行数和列数。最坏情况下，我们从左下角移动到右上角，经过的路径长度为。</li><li>空间复杂度：O(1)。</li></ul><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Python3 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1306. Jump Game III</title>
      <link href="/2020/02/04/1306/"/>
      <url>/2020/02/04/1306/</url>
      
        <content type="html"><![CDATA[<h1 id="1306-Jump-Game-III"><a href="#1306-Jump-Game-III" class="headerlink" title="1306. Jump Game III"></a>1306. Jump Game III</h1><h3 id="题目描述（难度：中等）"><a href="#题目描述（难度：中等）" class="headerlink" title="题目描述（难度：中等）"></a>题目描述（难度：中等）</h3><p><img src="https://i.loli.net/2020/02/04/JmLYcaMZ8dS29hb.png" alt=""></p><h3 id="解题思路：BFS"><a href="#解题思路：BFS" class="headerlink" title="解题思路：BFS"></a>解题思路：BFS</h3><p>当我们每次位于 i 位置时，我们会困惑于该跳到哪个位置是最优的。因此可采取以下贪心法则：如果跳到位置 j 时下一次可以跳得最远，那么我们就选取该位置。如下图所示，当我们位于初始位置 2（i = 0） 时，可以跳到黄色位置，由于 3 比 1 跳得远，因此我们选择跳到 3 的位置。</p><p><img src="https://i.loli.net/2020/02/04/m1dBWsPco8wUCzD.gif" alt="fig 1"></p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><pre><code>class Solution:    def canReach(self, arr: List[int], start: int) -&gt; bool:        # 边界条件        if arr[start] == 0:            return True        n = len(arr)        used = {start} # 已被访问过的结点保存在此集合中        q = collections.deque([start])  # 初始化队列q        while q:            u = q.popleft()            for v in [u - arr[u],u + arr[u]]:                if 0 &lt;= v &lt; n and v not in used:                    if arr[v] == 0:                        return True                    used.add(v)                    q.append(v)        return False</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N)，遍历了一遍数组。</li><li>空间复杂度：O(N)，使用了集合和队列。</li></ul><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ul><li>[跳跃游戏 Ⅱ](//0045. Jump Game II.md)</li><li>跳跃游戏 Ⅲ</li><li>跳跃游戏 Ⅳ</li><li>跳跃游戏 Ⅴ</li></ul><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>代码比较简单，思路要理清~加油！</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 队列 </tag>
            
            <tag> BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>45. Jump Game II</title>
      <link href="/2020/02/03/0045/"/>
      <url>/2020/02/03/0045/</url>
      
        <content type="html"><![CDATA[<h1 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45. Jump Game II"></a>45. Jump Game II</h1><h3 id="题目描述（难度：困难）"><a href="#题目描述（难度：困难）" class="headerlink" title="题目描述（难度：困难）"></a>题目描述（难度：困难）</h3><p><img src="https://i.loli.net/2020/02/03/fyHsrJbXAESFC8a.png" alt=""></p><h3 id="解题思路：贪心法则"><a href="#解题思路：贪心法则" class="headerlink" title="解题思路：贪心法则"></a>解题思路：贪心法则</h3><p>当我们每次位于 i 位置时，我们会困惑于该跳到哪个位置是最优的。因此可采取以下贪心法则：如果跳到位置 j 时下一次可以跳得最远，那么我们就选取该位置。如下图所示，当我们位于初始位置 2（i = 0） 时，可以跳到黄色位置，由于 3 比 1 跳得远，因此我们选择跳到 3 的位置。</p><p><img src="https://i.loli.net/2020/02/03/GeP7vgIOfTkt3jN.png" alt="fig 1"></p><p>现在我们位于位置 3 ，黄色点是可以跳到的位置，因为跳到 4 时可以跳得更远，因此我们选择跳到位置 4 。</p><p><img src="https://i.loli.net/2020/02/03/xstYGP4vLiWfqbO.png" alt="fig 2"></p><h3 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h3><pre><code>class Solution:    def jump(self, nums: List[int]) -&gt; int:        steps = 0        end = 0        maxposition = 0  # maxposition 为每次跳跃最优的位置        for i in range(len(nums) - 1):            maxposition = max(maxposition, nums[i] + i)            # 当我们找到了可以跳的最优位置，step + 1            if i == end:                end = maxposition                steps += 1        return steps</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N)。N 是数组的长度，我们遍历了一遍数组。</li><li>空间复杂度：O(1)。我们仅使用了 <code>steps</code>，<code>end</code>，<code>maxpositon</code> 等有限的额外空间。</li></ul><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><ul><li>跳跃游戏</li><li>跳跃游戏 Ⅲ</li><li>跳跃游戏 Ⅳ</li><li>跳跃游戏 Ⅴ</li></ul><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>代码比较简单，思路要理清~加油！</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1. Two Sum</title>
      <link href="/2020/01/31/0001/"/>
      <url>/2020/01/31/0001/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1. Two Sum"></a>1. Two Sum</h1><h3 id="题目描述（难度：简单）"><a href="#题目描述（难度：简单）" class="headerlink" title="题目描述（难度：简单）"></a>题目描述（难度：简单）</h3><p><img src="https://i.loli.net/2020/02/07/drzu8OcZ9VhbKoG.png" alt=""></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>通过迭代将元素添加到哈希表中，同时我们比较该元素的对应元素是否已经存在与哈希表中，如果存在，我们直接返回答案。</p><p><img src="https://i.loli.net/2020/02/07/COeJNI5itlf8qLV.gif" alt="fig 1"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        hashmap <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> idx<span class="token punctuation">,</span> num <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> target <span class="token operator">-</span> num <span class="token keyword">in</span> hashmap<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>hashmap<span class="token punctuation">[</span>target <span class="token operator">-</span> num<span class="token punctuation">]</span><span class="token punctuation">,</span>idx<span class="token punctuation">]</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                hashmap<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> idx</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(N)</li></ul><h3 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h3><p>不妨我们趁热打铁，看看进阶题目！</p><ul><li>15.三数之和</li><li>18.四数之和</li></ul><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>373. Find K Pairs with Smallest Sums</title>
      <link href="/2020/01/24/0151-wei-wan-cheng/"/>
      <url>/2020/01/24/0151-wei-wan-cheng/</url>
      
        <content type="html"><![CDATA[<h3 id="解法一：暴力"><a href="#解法一：暴力" class="headerlink" title="解法一：暴力"></a>解法一：暴力</h3><pre class=" language-java"><code class="language-java">        String emptyStr<span class="token operator">=</span><span class="token string">" "</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> s1 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>emptyStr<span class="token punctuation">)</span><span class="token punctuation">;</span>        StringBuilder sb<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> s1<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String str<span class="token operator">=</span>s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token keyword">while</span> <span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>emptyStr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               str<span class="token operator">=</span>str<span class="token punctuation">.</span><span class="token function">replaceAll</span><span class="token punctuation">(</span>emptyStr<span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>emptyStr<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>作者：da<span class="token operator">-</span>yu<span class="token operator">-</span>da<span class="token operator">-</span>yu<span class="token operator">-</span>pao链接：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>leetcode<span class="token operator">-</span>cn<span class="token punctuation">.</span>com<span class="token operator">/</span>problems<span class="token operator">/</span>reverse<span class="token operator">-</span>words<span class="token operator">-</span>in<span class="token operator">-</span>a<span class="token operator">-</span>string<span class="token operator">/</span>solution<span class="token operator">/</span>2ms<span class="token operator">-</span>ji<span class="token operator">-</span>bai<span class="token operator">-</span>99de<span class="token operator">-</span>yong<span class="token operator">-</span>hu<span class="token operator">-</span>fang<span class="token operator">-</span>fa<span class="token operator">-</span>you<span class="token operator">-</span>yu<span class="token operator">-</span>javade<span class="token operator">-</span>zi<span class="token operator">-</span>f<span class="token operator">/</span>来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseWords</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token string">' '</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>s<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">reverseWords</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">:</span>        s <span class="token operator">=</span> s<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 去除首尾的空格</span>        start<span class="token punctuation">,</span>end <span class="token operator">=</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>s<span class="token punctuation">)</span>         res <span class="token operator">=</span> <span class="token string">''</span>        <span class="token keyword">while</span> start <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> s<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true"># 如果找到了一个单词</span>                res <span class="token operator">+=</span> s<span class="token punctuation">[</span>start<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span>end<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">' '</span>                <span class="token keyword">while</span> s<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">:</span>  <span class="token comment" spellcheck="true"># 找到一个单词之后，start 略过中间的多个空格</span>                    start <span class="token operator">-=</span> <span class="token number">1</span>                end <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token number">1</span>            start <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">return</span> res <span class="token operator">+</span> s<span class="token punctuation">[</span><span class="token punctuation">:</span>end<span class="token punctuation">]</span></code></pre><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>不是因为希望才去坚持，而是因为坚持才有了希望~加油！</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>373. Find K Pairs with Smallest Sums</title>
      <link href="/2020/01/24/0373/"/>
      <url>/2020/01/24/0373/</url>
      
        <content type="html"><![CDATA[<h3 id="解法一：暴力"><a href="#解法一：暴力" class="headerlink" title="解法一：暴力"></a>解法一：暴力</h3><p>枚举所有组合，按照和排序，最后返回前 K 项。</p><p><img src="https://i.loli.net/2020/02/03/jWNcHnoGpazt7wT.png" alt="fig 1"></p><pre class=" language-python3"><code class="language-python3">def kSmallestPairs(self, nums1, nums2, k):    return sorted(itertools.product(nums1, nums2), key=sum)[:k]</code></pre><h3 id="解法二：暴力标准解"><a href="#解法二：暴力标准解" class="headerlink" title="解法二：暴力标准解"></a>解法二：暴力标准解</h3><p>这个解法更加标准，因为上面的解法生成的是元组不是列表。</p><pre class=" language-python3"><code class="language-python3">def kSmallestPairs(self, nums1, nums2, k):    return map(list, sorted(itertools.product(nums1, nums2), key=sum)[:k])</code></pre><h3 id="解法三：优化的暴力"><a href="#解法三：优化的暴力" class="headerlink" title="解法三：优化的暴力"></a>解法三：优化的暴力</h3><p>仍然遍历所有对，但仅使用生成器和使用大小为 k 的堆<code>heapq.nsmallest</code>。 因此，这仅需要 O(k) 的额外内存和 O(mn log k) 的时间。</p><pre><code>def kSmallestPairs(self, nums1, nums2, k):    return map(list, heapq.nsmallest(k, itertools.product(nums1, nums2), key=sum))</code></pre><h3 id="解法四：堆"><a href="#解法四：堆" class="headerlink" title="解法四：堆"></a>解法四：堆</h3><p>不计算整个矩阵，而将每一行变成三元组<code>[u + v，u，v]</code>的生成器，仅在要求计算下一行时才计算下一行，然后将这些生成器与堆合并。 占用 O(m + k * log(m)) 的时间复杂度和 O(m) 的空间复杂度。</p><pre class=" language-python3"><code class="language-python3">def kSmallestPairs(self, nums1, nums2, k):    streams = map(lambda u: ([u+v, u, v] for v in nums2), nums1)    stream = heapq.merge(*streams)    return [suv[1:] for suv in itertools.islice(stream, k)]</code></pre><h3 id="解法五：优先队列"><a href="#解法五：优先队列" class="headerlink" title="解法五：优先队列"></a>解法五：优先队列</h3><p>它仅从矩阵左上角的第一对开始，然后根据需要从那里开始扩展。 每当将一对选择为输出结果时，该行中的下一对就会添加到当前选项的优先队列中。 同样，如果所选对是该行中的第一对，则将下一行中的第一对添加到队列中。</p><p><img src="https://i.loli.net/2020/02/03/u6yVbrnkLpZj1Io.png" alt="fig 2"></p><pre class=" language-python3"><code class="language-python3">class Solution:    def kSmallestPairs(self, nums1, nums2, k):        queue = []        def push(i, j):            if i < len(nums1) and j < len(nums2):                heapq.heappush(queue, [nums1[i] + nums2[j], i, j])        push(0, 0)        pairs = []        while queue and len(pairs) < k:            _, i, j = heapq.heappop(queue)            pairs.append([nums1[i], nums2[j]])            push(i, j + 1)            if j == 0:                push(i + 1, 0)        return pairs</code></pre><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><p>不是因为希望才去坚持，而是因为坚持才有了希望~加油！</p><p><img src="https://i.loli.net/2020/02/03/4WgNw6XZHQJ2hBV.png" alt="添加好友共同进步~"></p><p>如果觉得对您有帮助，别忘了点击一个 <a href="https://github.com/ML-ZimingMeng/LeetCode-Python3" target="_blank" rel="noopener">star⭐</a> 哦^_^</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列和广度优先搜索（BFS）、栈和深度优先搜索（DFS）及Java模板</title>
      <link href="/2019/11/09/dui-lie-he-guang-du-you-xian-sou-suo-bfs-zhan-he-shen-du-you-xian-sou-suo-dfs-ji-java-mo-ban/"/>
      <url>/2019/11/09/dui-lie-he-guang-du-you-xian-sou-suo-bfs-zhan-he-shen-du-you-xian-sou-suo-dfs-ji-java-mo-ban/</url>
      
        <content type="html"><![CDATA[<p>本文为<a href="[https://leetcode-cn.com/explore/learn/card/queue-stack/217/queue-and-bfs/870/](https://leetcode-cn.com/explore/learn/card/queue-stack/217/queue-and-bfs/870/)">Leetcode</a>学习笔记</p><h2 id="队列和广度优先搜索（BFS）"><a href="#队列和广度优先搜索（BFS）" class="headerlink" title="队列和广度优先搜索（BFS）"></a>队列和广度优先搜索（BFS）</h2><p>广度优先搜索（BFS）的一个常见应用是找出从根结点到目标结点的最短路径。在本文中，我们提供了一个示例来解释在 BFS 算法中是如何逐步应用队列的。</p><h5 id="1-结点的处理顺序是什么？"><a href="#1-结点的处理顺序是什么？" class="headerlink" title="1. 结点的处理顺序是什么？"></a>1. 结点的处理顺序是什么？</h5><p>在第一轮中，我们处理根结点。在第二轮中，我们处理根结点旁边的结点；在第三轮中，我们处理距根结点两步的结点；等等等等。</p><p>与树的层序遍历类似，越是接近根结点的结点将越早地遍历。</p><p>如果在第 k 轮中将结点 X 添加到队列中，则根结点与 X 之间的最短路径的长度恰好是 k。也就是说，第一次找到目标结点时，你已经处于最短路径中。</p><h5 id="2-队列的入队和出队顺序是什么？"><a href="#2-队列的入队和出队顺序是什么？" class="headerlink" title="2. 队列的入队和出队顺序是什么？"></a>2. 队列的入队和出队顺序是什么？</h5><p>我们首先将根结点排入队列。然后在每一轮中，我们逐个处理已经在队列中的结点，并将所有邻居添加到队列中。值得注意的是，新添加的节点不会立即遍历，而是在下一轮中处理。</p><p>结点的处理顺序与它们添加到队列的顺序是完全相同的顺序，即先进先出（FIFO）。这就是我们在 BFS 中使用队列的原因。</p><blockquote><p>在特定问题中执行 BFS 之前确定结点和边缘非常重要。通常，结点将是实际结点或是状态，而边缘将是实际边缘或可能的转换。</p></blockquote><h5 id="模板-I"><a href="#模板-I" class="headerlink" title="模板 I"></a><em>模板 I</em></h5><pre><code>/** * Return the length of the shortest path between root and target node. */int BFS(Node root, Node target) {    Queue&lt;Node&gt; queue;  // store all nodes which are waiting to be processed    int step = 0;       // number of steps neeeded from root to current node    // initialize    add root to queue;    // BFS    while (queue is not empty) {        step = step + 1;        // iterate the nodes which are already in the queue        int size = queue.size();        for (int i = 0; i &lt; size; ++i) {            Node cur = the first node in queue;            return step if cur is target;            for (Node next : the neighbors of cur) {                add next to queue;            }            remove the first node from queue;        }    }    return -1;          // there is no path from root to target}</code></pre><ol><li>如代码所示，在每一轮中，队列中的结点是等待处理的结点。</li><li>在每个更外一层的 while 循环之后，我们距离根结点更远一步。变量 step 指示从根结点到我们正在访问的当前结点的距离。</li></ol><h5 id="模板II"><a href="#模板II" class="headerlink" title="模板II"></a><em>模板II</em></h5><p>有时，确保我们永远不会访问一个结点两次很重要。否则，我们可能陷入无限循环。如果是这样，我们可以在上面的代码中添加一个哈希集来解决这个问题。这是修改后的伪代码：</p><pre><code>/** * Return the length of the shortest path between root and target node. */int BFS(Node root, Node target) {    Queue&lt;Node&gt; queue;  // store all nodes which are waiting to be processed    Set&lt;Node&gt; used;     // store all the used nodes    int step = 0;       // number of steps neeeded from root to current node    // initialize    add root to queue;    add root to used;    // BFS    while (queue is not empty) {        step = step + 1;        // iterate the nodes which are already in the queue        int size = queue.size();        for (int i = 0; i &lt; size; ++i) {            Node cur = the first node in queue;            return step if cur is target;            for (Node next : the neighbors of cur) {                if (next is not in used) {                    add next to queue;                    add next to used;                }            }            remove the first node from queue;        }    }    return -1;          // there is no path from root to target}</code></pre><blockquote><p>有两种情况你不需要使用哈希集：</p><ol><li>你完全确定没有循环，例如，在树遍历中；</li><li>你确实希望多次将结点添加到队列中。</li></ol></blockquote><h2 id="栈和深度优先搜索（DFS）"><a href="#栈和深度优先搜索（DFS）" class="headerlink" title="栈和深度优先搜索（DFS）"></a>栈和深度优先搜索（DFS）</h2><p>与 BFS 类似，<strong>深度优先搜索</strong>（DFS）也可用于查找从根结点到目标结点的路径。在本文中，我们提供了示例来解释 DFS 是如何工作的以及栈是如何逐步帮助 DFS 工作的。<br><a href="https://leetcode-cn.com/explore/learn/card/queue-stack/219/stack-and-dfs/881/" target="_blank" rel="noopener">图</a></p><h5 id="1-结点的处理顺序是什么？-1"><a href="#1-结点的处理顺序是什么？-1" class="headerlink" title="1. 结点的处理顺序是什么？"></a>1. 结点的处理顺序是什么？</h5><p>在上面的例子中，我们从根结点 A 开始。首先，我们选择结点 B 的路径，并进行回溯，直到我们到达结点 E，我们无法更进一步深入。然后我们回溯到 A 并选择第二条路径到结点 C 。从 C 开始，我们尝试第一条路径到 E 但是 E 已被访问过。所以我们回到 C 并尝试从另一条路径到 F。最后，我们找到了 G。</p><p>总的来说，在我们到达最深的结点之后，我们只会回溯并尝试另一条路径。</p><blockquote><p>因此，你在 DFS 中找到的第一条路径并不总是最短的路径。例如，在上面的例子中，我们成功找出了路径 A-&gt; C-&gt; F-&gt; G 并停止了 DFS。但这不是从 A 到 G 的最短路径。</p></blockquote><h5 id="2-栈的入栈和退栈顺序是什么？"><a href="#2-栈的入栈和退栈顺序是什么？" class="headerlink" title="2. 栈的入栈和退栈顺序是什么？"></a>2. 栈的入栈和退栈顺序是什么？</h5><p>我们首先将根结点推入到栈中；然后我们尝试第一个邻居 B 并将结点 B 推入到栈中；等等等等。当我们到达最深的结点 E 时，我们需要回溯。当我们回溯时，我们将从栈中弹出最深的结点，这实际上是推入到栈中的最后一个结点。</p><p>结点的处理顺序是完全相反的顺序，就像它们被添加到栈中一样，它是后进先出（LIFO）。这就是我们在 DFS 中使用栈的原因。</p><p>正如我们在本章的描述中提到的，在大多数情况下，我们在能使用 BFS 时也可以使用 DFS。但是有一个重要的区别：<strong>遍历顺序</strong>。</p><p>与 BFS 不同，<strong>更早访问的结点可能不是更靠近根结点的结点</strong>。因此，你在 DFS 中找到的第一条路径<strong>可能不是最短路径</strong>。</p><h5 id="模板-递归"><a href="#模板-递归" class="headerlink" title="模板 - 递归"></a><em>模板 - 递归</em></h5><pre><code>/* * Return true if there is a path from cur to target. */boolean DFS(Node cur, Node target, Set&lt;Node&gt; visited) {    return true if cur is target;    for (next : each neighbor of cur) {        if (next is not in visited) {            add next to visted;            return true if DFS(next, target, visited) == true;        }    }    return false;}</code></pre><p>当我们递归地实现 DFS 时，似乎不需要使用任何栈。但实际上，我们使用的是由系统提供的隐式栈，也称为调用栈。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a><em>示例</em></h5><p>让我们看一个例子。我们希望在下图中找到结点 0 和结点 3 之间的路径。我们还会在每次调用期间显示栈的状态。<br><img src="https://upload-images.jianshu.io/upload_images/19942712-20b7c9e726b380f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Stack Status"><br>在每个堆栈元素中，都有一个整数 <strong>cur</strong>，一个整数 <strong>target</strong>，一个对<strong>访问过的</strong>数组的引用和一个对数组<strong>边界</strong>的引用，这些正是我们在 DFS 函数中的参数。我们只在上面的栈中显示 <strong>cur</strong>。</p><p>每个元素都需要固定的空间。栈的大小正好是 DFS 的深度。因此，在最坏的情况下，维护系统栈需要 O(h)，其中 h 是 DFS 的最大深度。在计算空间复杂度时，永远不要忘记考虑系统栈。</p><blockquote><p>在上面的模板中，我们在找到第一条路径时停止。<br>如果你想找到最短路径呢？<br>提示：再添加一个参数来指示你已经找到的最短路径。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BFS </tag>
            
            <tag> Python </tag>
            
            <tag> 算法 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法面试中应该注意的事</title>
      <link href="/2019/11/03/suan-fa-mian-shi-bi-xu-yao-zhu-yi-de-shi/"/>
      <url>/2019/11/03/suan-fa-mian-shi-bi-xu-yao-zhu-yi-de-shi/</url>
      
        <content type="html"><![CDATA[<p>通过学习拉勾网资深软件工程师su yong的算法面试课程，收获很大。如果您也有兴趣，欢迎点击<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=3#/detail/pc?id=29" target="_blank" rel="noopener">这里</a>聆听。下面对算法面试内容进行总结。</p><h1 id="刷题、简历、面试"><a href="#刷题、简历、面试" class="headerlink" title="刷题、简历、面试"></a>刷题、简历、面试</h1><h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><p>刷题是必不可少的环节。</p><p>无论你是刚刚毕业的计算机系的学生，还是已经有了很多年工作经验的工程师，你即将要面对的是高强度的面试。每个公司平均都有好几轮技术面试，包括电话面试和现场面试，每轮面试的时间是 45 分钟到 1 个小时，除去聊天谈话的时间，每一轮留给你的时间大概就是 30 分钟，要能拿到优秀的结果，一般都必须解答出两个算法题，而你要面试的公司可能不止一家。那么，要让自己始终保持良好的水准，没有一个强化训练的辅助，你是很难过关的，因此刷题就是必不可少的环节。</p><p>但是在刷题之前，必须要先弄清楚一个问题：你要选择什么编程语言？</p><h2 id="选择编程语言"><a href="#选择编程语言" class="headerlink" title="选择编程语言"></a>选择编程语言</h2><p>这往往取决于你的求职岗位是什么。</p><p>如果你要做一名前端的网络工程师，那么你必须要能熟练地用 JavaScript 去解算法题。如果你要做一名后端的工程师，那么可以选择的就很多了，其中 Java，Python 和 C++ 都是首选。如果你想要做一名数据分析工程师或者涉及机器学习和人工智能方向的，Pyhton 是不二选择。我自己方向是机器学习，因此我准备用python进行刷题。</p><p>讲师在刚开始刷题的时候用的是 Java，虽然他平时的工作并不用它，但是发现，用 Java 刷题有几个好处。</p><p>1. Java 是强类型语言，它能帮助更好地理解输入输出的要求，对于每个变量的类型都要清楚。</p><p>2. Java 提供丰富的类库，比如 Deque、PriorityQueue、LinkedList、Stack 等，有了这些，可以更加专注于对算法本身的思考，而不用考虑如何去实现这些数据结构。这些库拿来用就好，节省了很多时间。</p><p>3. LeetCode 上的很多题目都有 Java 的解法，如果一道题目做不出来，就会看看 LeetCode 的解法，比较方便。</p><p>后来讲师明确地知道自己要做一名前端的网络工程师，在决定跳槽去大厂的时候，不得不用 JavaScript 去重新刷题，这样一来，浪费了不少时间。所以在选择语言的时候，多考虑自己的求职方向和岗位要求。建议大量联系大厂的招聘专员，获取专业的建议。</p><h2 id="刷题方法"><a href="#刷题方法" class="headerlink" title="刷题方法"></a>刷题方法</h2><p>选择好了编程语言后，接下来要考虑的就是怎么合理地刷题了。</p><p>现在 LeetCode 上面有上千道题目，究竟要刷多少道题才行呢？其实最关键的不是量的问题，而是质的问题，而且由时间决定。</p><p>首先，根据自己平时的刷题速度，预留足够的刷题时间。</p><p>“我在刷题的时候，会给自己至少三个月的时间专心刷题，周一到周五每晚分配 2 个小时，周末也会刷。有时候由于要兼顾工作，平时晚上没有太多时间，我就会多留点时间到周末，把平时没有刷的题在周末补回来。根据平时的刷题速度，我可以计算出在这三个月的时间内，自己能一共做多少题。”</p><p>然后，刷题时可以有选择性地分类做题。</p><p>接下来，按照 LeetCode 的题目分类去做。先做树的题目，然后是图论，因为图论可以看作是树的一种扩展，然后是递归、回溯，之后是 DFS、BFS，然后是动态规划，最后是字符串和数组。分类刷题有如下几个好处。</p><p>1. 能有效地巩固知识点。</p><p>2. 帮助整理解题的思路和归纳方法。</p><p>3. 能有效地提高解题的速度。</p><p>另外，要练习如何在白板上写代码。</p><p>很多大厂都要求你在白板上写代码，大家不要小看了这点，很多人都认为用电脑做了几百道题之后，还怕在白板上写代码么？在白板上写代码的感觉跟敲键盘是完全不同的，有几点需要注意。</p><p>1. 字迹要清晰。这样一来面试官才能很好地跟你探讨代码，更重要的是，面试官要记录下你写的代码，然后原封不动地递交给招聘委员会的成员或者其他人审核，如果因为字迹不清导致记录失真就很不好了。</p><p>2. 间距要把握好。有些白板并不大，要能够在一块小白板上挤下很多代码是不可能的，这就要看你如何规划代码的书写了，这些都要通过不断地练习。</p><p>3. 思路清晰。写白板，是你和面试官沟通的一个重要环节，你的任务是要清晰地展现自己的思路，将它们转变为代码，并且，你要确保面试官能跟上你的节奏。如果你东写一点函数，西写一点结构定义，那就会很凌乱。</p><p>锻炼写白板的能力，最好的方法就是找一块白板，在它上面练习。一般这个可以在你拥有了一定的刷题量的基础上进行，不必一开始就这样练习。另外，也可以在纸上练习，把纸想象成白板，也能达到很不错的效果，尤其对锻炼清晰的笔迹有很大的帮助。</p><p>为了避免遗忘，养成整理回顾的习惯。</p><p>刷题的时候，会出现一种情况，之前刷过的题目一下就忘记了。要克服这种情况的出现，我用下面的办法。</p><p>1. 周末的时候回顾一下这一周做过的题目，主要是整理思路。</p><p>2. 把这周里出现的难啃的题目单独拿出来，记录到难题笔记里，反复看。</p><p>3. 刷题的时候，尽量把思路理清，而不是记代码。</p><p>最后，一定要把自己刷过的题目和最好的解法写下来。</p><p>我会按照老师的说法，把刷过的题目和最好的解法写下来，写到我的<a href="https://github.com/ML-ZimingMeng/python-problems-and-solutions" target="_blank" rel="noopener">github</a>上，欢迎一起交流。</p><h2 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h2><p>简历就是你的门面，好的简历能让你在众多的求职者中脱颖而出。很多公司的职位都是很有限的，如果招聘人员能够快速准确地从你的简历里找出他们想要的东西，比如你的技术，经验，或者研究成果等，那么你就会有更大地机会进入到面试的环节，另外，最重要的一点，想一想你为了能面试这家公司，付出了那么多的心血去刷题，最后因为简历没能被看上而与机会失之交臂，那是多么多么的不应该啊！可以说，好的简历是打开面试机会的大门。</p><p>怎么样去写好一份简历呢？</p><p>一、要有针对性</p><p>你的简历必须要凸显出你才是适合这个职务的不二人选。</p><p>每个职务的招聘一般都会有一些基本的要求，比如某个职务要招的是前端网络工程师，要求有 5 年以上的工作经验，精通 JavaScript，HTML5，CSS3，熟悉 React 框架等，那么你的简历必须要想办法体现出你能满足上面的基本要求。</p><p>可以通过你的工作履历表来体现出你有 5 年以上的工作经验，通过罗列出与前端相关的技术名词作为你所拥有和掌握的技术来体现你适合这个岗位的技术需求。有些人既懂得 Java，SQL，也懂得 JavaScript，但是在简历当中却把 JavaScript 罗列在了后面，有时候会让人觉得 JavaScript 也许并不是你的强项，也许你更适合做后端的工程师。换句话说，你的简历必须要能投其所好。</p><p>二、写好工作履历</p><p>招聘人员会把大部分时间花在阅读你的工作履历上。对于一个要谋求软件工程师职务的人的简历，必须要做到以下几点。</p><p>1. 对于以往的每一份工作，都必须写明公司的名称，起始时间和终止时间。</p><p>2. 针对每份工作，言简意赅地罗列出自己做过的项目，以及你在项目中扮演的角色。</p><p>3. 最好能体现出每个项目最终的结果以及所带来的影响。</p><p>在罗列项目的时候，最好能写明，你在这个项目中扮演的角色是什么，采用了什么样架构，使用了什么编程语言，解决了什么问题，达到了什么效果或者产生了什么样的影响。</p><p>三、控制页数</p><p>大厂的招聘人员，一般都会在每天分配出固定的时间来审阅大量的简历，你的简历一般都是以电子版的形式存储在系统中，招聘人员通过关键字搜索来找出合适的简历，然后加以阅读。通常，你的简历最好不要超过两页，最好能控制在一页。</p><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>当你拿到面试通知的时候，离成功就差最后一步了，只需要你在面试中好好表现，发挥出你的水平。</p><p>面试不光是脑力活，同时也是体力活，如何让你的脑力和体力都能跟上高强度的大厂技术面试呢？一种比较行之有效的方法就是多拿一些中小型公司练手。</p><p>中小型公司有时候比较倾向于考察你的经验，这是一个锻炼你跟面试官交流经验的绝佳机会，更重要的是，通过这些练手，能让你更好地梳理自己的技术经验，总结出适合你自己的交谈风格，这样，当你在大厂里被问到工作经验相关的问题时，就能脱口而出，而且条理清晰，这些其实跟刷题一样，都是要通过不断地练习的。</p><p>另外，中小型公司也会考察算法题，但是难度一般来说不会特别难，这是一个检验你算法和数据结构知识水平以及能不能写出高质量代码的难得的训练机会。有些中小型公司的技术面试也是出了名的难，如果你在这些面试中失败了，这是好事，你要从中吸取教训，把答得不好的题反复思考一下，在哪里跌倒就在哪里爬起来。</p><p>总之，通过一些真刀真枪地实战，可以帮助你迅速地调整面试的状态，记住，你的最终目标是你心仪的公司，不要被中间的一两个失利的战斗影响到自己，找出问题所在，为下一个面试做好准备。</p><p>下面说一下现场面试，现场面试真正要考察的是下面几个方面。</p><p>1. 你的技术水平够不够硬。</p><p>也就是说，你能不能在 30 分钟之类写出一道简单的题目以及一道中等甚至更难的题目。如果你的知识点不够牢固，写题的速度不够快，是非常难过这关的。但是，只要你努力刷题，一定会有好的结果。</p><p>2. 你分析问题的能力。</p><p>当面试官给你出问题的时候，他最希望的，并不是看到你拿到题目立即写出答案，而是希望你能跟他交流，把你的想法说明白。就好比你和面试官是同事，你们在一起讨论问题一样，只不过他对这个问题早已有了自己的想法，他想听听你的意见，说不定你的方法更好。</p><p>3. 你将思想变为代码的能力。</p><p>如果你和面试官的交流过程中，能始终呈现出一种状态，迅速地将自己的思考转变为代码，然后清晰地写在白板上。就算你不能完美地写出一道题目的答案，我相信面试官也一定会满意的，因为这要比那些只能夸夸其谈而写不出代码的人要强太多。</p><p>4. 检查和分析代码的能力。</p><p>一般在你写出了代码后，面试官会让你举几种情况来考虑看看你的算法是否行得通。最好的做法就是你自己要主动地提出来，然后给出几个比较有代表性的测试输入，然后过一遍你的程序，分析出结果。最后，一定要去分析一下时间和空间复杂度。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>老话说，“书山有路勤为径，学海无涯苦作舟“，共勉！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
