<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>队列和广度优先搜索（BFS）、栈和深度优先搜索（DFS）及Java模板</title>
      <link href="/2019/11/09/dui-lie-he-guang-du-you-xian-sou-suo-bfs-zhan-he-shen-du-you-xian-sou-suo-dfs-ji-java-mo-ban/"/>
      <url>/2019/11/09/dui-lie-he-guang-du-you-xian-sou-suo-bfs-zhan-he-shen-du-you-xian-sou-suo-dfs-ji-java-mo-ban/</url>
      
        <content type="html"><![CDATA[<p>本文为<a href="[https://leetcode-cn.com/explore/learn/card/queue-stack/217/queue-and-bfs/870/](https://leetcode-cn.com/explore/learn/card/queue-stack/217/queue-and-bfs/870/)">Leetcode</a>学习笔记</p><h2 id="队列和广度优先搜索（BFS）"><a href="#队列和广度优先搜索（BFS）" class="headerlink" title="队列和广度优先搜索（BFS）"></a>队列和广度优先搜索（BFS）</h2><p>广度优先搜索（BFS）的一个常见应用是找出从根结点到目标结点的最短路径。在本文中，我们提供了一个示例来解释在 BFS 算法中是如何逐步应用队列的。</p><h5 id="1-结点的处理顺序是什么？"><a href="#1-结点的处理顺序是什么？" class="headerlink" title="1. 结点的处理顺序是什么？"></a>1. 结点的处理顺序是什么？</h5><p>在第一轮中，我们处理根结点。在第二轮中，我们处理根结点旁边的结点；在第三轮中，我们处理距根结点两步的结点；等等等等。</p><p>与树的层序遍历类似，越是接近根结点的结点将越早地遍历。</p><p>如果在第 k 轮中将结点 X 添加到队列中，则根结点与 X 之间的最短路径的长度恰好是 k。也就是说，第一次找到目标结点时，你已经处于最短路径中。</p><h5 id="2-队列的入队和出队顺序是什么？"><a href="#2-队列的入队和出队顺序是什么？" class="headerlink" title="2. 队列的入队和出队顺序是什么？"></a>2. 队列的入队和出队顺序是什么？</h5><p>我们首先将根结点排入队列。然后在每一轮中，我们逐个处理已经在队列中的结点，并将所有邻居添加到队列中。值得注意的是，新添加的节点不会立即遍历，而是在下一轮中处理。</p><p>结点的处理顺序与它们添加到队列的顺序是完全相同的顺序，即先进先出（FIFO）。这就是我们在 BFS 中使用队列的原因。</p><blockquote><p>在特定问题中执行 BFS 之前确定结点和边缘非常重要。通常，结点将是实际结点或是状态，而边缘将是实际边缘或可能的转换。</p></blockquote><h5 id="模板-I"><a href="#模板-I" class="headerlink" title="模板 I"></a><em>模板 I</em></h5><pre><code>/** * Return the length of the shortest path between root and target node. */int BFS(Node root, Node target) {    Queue&lt;Node&gt; queue;  // store all nodes which are waiting to be processed    int step = 0;       // number of steps neeeded from root to current node    // initialize    add root to queue;    // BFS    while (queue is not empty) {        step = step + 1;        // iterate the nodes which are already in the queue        int size = queue.size();        for (int i = 0; i &lt; size; ++i) {            Node cur = the first node in queue;            return step if cur is target;            for (Node next : the neighbors of cur) {                add next to queue;            }            remove the first node from queue;        }    }    return -1;          // there is no path from root to target}</code></pre><ol><li>如代码所示，在每一轮中，队列中的结点是等待处理的结点。</li><li>在每个更外一层的 while 循环之后，我们距离根结点更远一步。变量 step 指示从根结点到我们正在访问的当前结点的距离。</li></ol><h5 id="模板II"><a href="#模板II" class="headerlink" title="模板II"></a><em>模板II</em></h5><p>有时，确保我们永远不会访问一个结点两次很重要。否则，我们可能陷入无限循环。如果是这样，我们可以在上面的代码中添加一个哈希集来解决这个问题。这是修改后的伪代码：</p><pre><code>/** * Return the length of the shortest path between root and target node. */int BFS(Node root, Node target) {    Queue&lt;Node&gt; queue;  // store all nodes which are waiting to be processed    Set&lt;Node&gt; used;     // store all the used nodes    int step = 0;       // number of steps neeeded from root to current node    // initialize    add root to queue;    add root to used;    // BFS    while (queue is not empty) {        step = step + 1;        // iterate the nodes which are already in the queue        int size = queue.size();        for (int i = 0; i &lt; size; ++i) {            Node cur = the first node in queue;            return step if cur is target;            for (Node next : the neighbors of cur) {                if (next is not in used) {                    add next to queue;                    add next to used;                }            }            remove the first node from queue;        }    }    return -1;          // there is no path from root to target}</code></pre><blockquote><p>有两种情况你不需要使用哈希集：</p><ol><li>你完全确定没有循环，例如，在树遍历中；</li><li>你确实希望多次将结点添加到队列中。</li></ol></blockquote><h2 id="栈和深度优先搜索（DFS）"><a href="#栈和深度优先搜索（DFS）" class="headerlink" title="栈和深度优先搜索（DFS）"></a>栈和深度优先搜索（DFS）</h2><p>与 BFS 类似，<strong>深度优先搜索</strong>（DFS）也可用于查找从根结点到目标结点的路径。在本文中，我们提供了示例来解释 DFS 是如何工作的以及栈是如何逐步帮助 DFS 工作的。<br><a href="https://leetcode-cn.com/explore/learn/card/queue-stack/219/stack-and-dfs/881/" target="_blank" rel="noopener">图</a></p><h5 id="1-结点的处理顺序是什么？-1"><a href="#1-结点的处理顺序是什么？-1" class="headerlink" title="1. 结点的处理顺序是什么？"></a>1. 结点的处理顺序是什么？</h5><p>在上面的例子中，我们从根结点 A 开始。首先，我们选择结点 B 的路径，并进行回溯，直到我们到达结点 E，我们无法更进一步深入。然后我们回溯到 A 并选择第二条路径到结点 C 。从 C 开始，我们尝试第一条路径到 E 但是 E 已被访问过。所以我们回到 C 并尝试从另一条路径到 F。最后，我们找到了 G。</p><p>总的来说，在我们到达最深的结点之后，我们只会回溯并尝试另一条路径。</p><blockquote><p>因此，你在 DFS 中找到的第一条路径并不总是最短的路径。例如，在上面的例子中，我们成功找出了路径 A-&gt; C-&gt; F-&gt; G 并停止了 DFS。但这不是从 A 到 G 的最短路径。</p></blockquote><h5 id="2-栈的入栈和退栈顺序是什么？"><a href="#2-栈的入栈和退栈顺序是什么？" class="headerlink" title="2. 栈的入栈和退栈顺序是什么？"></a>2. 栈的入栈和退栈顺序是什么？</h5><p>我们首先将根结点推入到栈中；然后我们尝试第一个邻居 B 并将结点 B 推入到栈中；等等等等。当我们到达最深的结点 E 时，我们需要回溯。当我们回溯时，我们将从栈中弹出最深的结点，这实际上是推入到栈中的最后一个结点。</p><p>结点的处理顺序是完全相反的顺序，就像它们被添加到栈中一样，它是后进先出（LIFO）。这就是我们在 DFS 中使用栈的原因。</p><p>正如我们在本章的描述中提到的，在大多数情况下，我们在能使用 BFS 时也可以使用 DFS。但是有一个重要的区别：<strong>遍历顺序</strong>。</p><p>与 BFS 不同，<strong>更早访问的结点可能不是更靠近根结点的结点</strong>。因此，你在 DFS 中找到的第一条路径<strong>可能不是最短路径</strong>。</p><h5 id="模板-递归"><a href="#模板-递归" class="headerlink" title="模板 - 递归"></a><em>模板 - 递归</em></h5><pre><code>/* * Return true if there is a path from cur to target. */boolean DFS(Node cur, Node target, Set&lt;Node&gt; visited) {    return true if cur is target;    for (next : each neighbor of cur) {        if (next is not in visited) {            add next to visted;            return true if DFS(next, target, visited) == true;        }    }    return false;}</code></pre><p>当我们递归地实现 DFS 时，似乎不需要使用任何栈。但实际上，我们使用的是由系统提供的隐式栈，也称为调用栈。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a><em>示例</em></h5><p>让我们看一个例子。我们希望在下图中找到结点 0 和结点 3 之间的路径。我们还会在每次调用期间显示栈的状态。<br><img src="https://upload-images.jianshu.io/upload_images/19942712-20b7c9e726b380f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Stack Status"><br>在每个堆栈元素中，都有一个整数 <strong>cur</strong>，一个整数 <strong>target</strong>，一个对<strong>访问过的</strong>数组的引用和一个对数组<strong>边界</strong>的引用，这些正是我们在 DFS 函数中的参数。我们只在上面的栈中显示 <strong>cur</strong>。</p><p>每个元素都需要固定的空间。栈的大小正好是 DFS 的深度。因此，在最坏的情况下，维护系统栈需要 O(h)，其中 h 是 DFS 的最大深度。在计算空间复杂度时，永远不要忘记考虑系统栈。</p><blockquote><p>在上面的模板中，我们在找到第一条路径时停止。<br>如果你想找到最短路径呢？<br>提示：再添加一个参数来指示你已经找到的最短路径。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> Python </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法面试中应该注意的事</title>
      <link href="/2019/11/03/suan-fa-mian-shi-bi-xu-yao-zhu-yi-de-shi/"/>
      <url>/2019/11/03/suan-fa-mian-shi-bi-xu-yao-zhu-yi-de-shi/</url>
      
        <content type="html"><![CDATA[<p>通过学习拉勾网资深软件工程师su yong的算法面试课程，收获很大。如果您也有兴趣，欢迎点击<a href="https://kaiwu.lagou.com/course/courseInfo.htm?courseId=3#/detail/pc?id=29" target="_blank" rel="noopener">这里</a>聆听。下面对算法面试内容进行总结。</p><h1 id="刷题、简历、面试"><a href="#刷题、简历、面试" class="headerlink" title="刷题、简历、面试"></a>刷题、简历、面试</h1><h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><p>刷题是必不可少的环节。</p><p>无论你是刚刚毕业的计算机系的学生，还是已经有了很多年工作经验的工程师，你即将要面对的是高强度的面试。每个公司平均都有好几轮技术面试，包括电话面试和现场面试，每轮面试的时间是 45 分钟到 1 个小时，除去聊天谈话的时间，每一轮留给你的时间大概就是 30 分钟，要能拿到优秀的结果，一般都必须解答出两个算法题，而你要面试的公司可能不止一家。那么，要让自己始终保持良好的水准，没有一个强化训练的辅助，你是很难过关的，因此刷题就是必不可少的环节。</p><p>但是在刷题之前，必须要先弄清楚一个问题：你要选择什么编程语言？</p><h2 id="选择编程语言"><a href="#选择编程语言" class="headerlink" title="选择编程语言"></a>选择编程语言</h2><p>这往往取决于你的求职岗位是什么。</p><p>如果你要做一名前端的网络工程师，那么你必须要能熟练地用 JavaScript 去解算法题。如果你要做一名后端的工程师，那么可以选择的就很多了，其中 Java，Python 和 C++ 都是首选。如果你想要做一名数据分析工程师或者涉及机器学习和人工智能方向的，Pyhton 是不二选择。我自己方向是机器学习，因此我准备用python进行刷题。</p><p>讲师在刚开始刷题的时候用的是 Java，虽然他平时的工作并不用它，但是发现，用 Java 刷题有几个好处。</p><p>1. Java 是强类型语言，它能帮助更好地理解输入输出的要求，对于每个变量的类型都要清楚。</p><p>2. Java 提供丰富的类库，比如 Deque、PriorityQueue、LinkedList、Stack 等，有了这些，可以更加专注于对算法本身的思考，而不用考虑如何去实现这些数据结构。这些库拿来用就好，节省了很多时间。</p><p>3. LeetCode 上的很多题目都有 Java 的解法，如果一道题目做不出来，就会看看 LeetCode 的解法，比较方便。</p><p>后来讲师明确地知道自己要做一名前端的网络工程师，在决定跳槽去大厂的时候，不得不用 JavaScript 去重新刷题，这样一来，浪费了不少时间。所以在选择语言的时候，多考虑自己的求职方向和岗位要求。建议大量联系大厂的招聘专员，获取专业的建议。</p><h2 id="刷题方法"><a href="#刷题方法" class="headerlink" title="刷题方法"></a>刷题方法</h2><p>选择好了编程语言后，接下来要考虑的就是怎么合理地刷题了。</p><p>现在 LeetCode 上面有上千道题目，究竟要刷多少道题才行呢？其实最关键的不是量的问题，而是质的问题，而且由时间决定。</p><p>首先，根据自己平时的刷题速度，预留足够的刷题时间。</p><p>“我在刷题的时候，会给自己至少三个月的时间专心刷题，周一到周五每晚分配 2 个小时，周末也会刷。有时候由于要兼顾工作，平时晚上没有太多时间，我就会多留点时间到周末，把平时没有刷的题在周末补回来。根据平时的刷题速度，我可以计算出在这三个月的时间内，自己能一共做多少题。”</p><p>然后，刷题时可以有选择性地分类做题。</p><p>接下来，按照 LeetCode 的题目分类去做。先做树的题目，然后是图论，因为图论可以看作是树的一种扩展，然后是递归、回溯，之后是 DFS、BFS，然后是动态规划，最后是字符串和数组。分类刷题有如下几个好处。</p><p>1. 能有效地巩固知识点。</p><p>2. 帮助整理解题的思路和归纳方法。</p><p>3. 能有效地提高解题的速度。</p><p>另外，要练习如何在白板上写代码。</p><p>很多大厂都要求你在白板上写代码，大家不要小看了这点，很多人都认为用电脑做了几百道题之后，还怕在白板上写代码么？在白板上写代码的感觉跟敲键盘是完全不同的，有几点需要注意。</p><p>1. 字迹要清晰。这样一来面试官才能很好地跟你探讨代码，更重要的是，面试官要记录下你写的代码，然后原封不动地递交给招聘委员会的成员或者其他人审核，如果因为字迹不清导致记录失真就很不好了。</p><p>2. 间距要把握好。有些白板并不大，要能够在一块小白板上挤下很多代码是不可能的，这就要看你如何规划代码的书写了，这些都要通过不断地练习。</p><p>3. 思路清晰。写白板，是你和面试官沟通的一个重要环节，你的任务是要清晰地展现自己的思路，将它们转变为代码，并且，你要确保面试官能跟上你的节奏。如果你东写一点函数，西写一点结构定义，那就会很凌乱。</p><p>锻炼写白板的能力，最好的方法就是找一块白板，在它上面练习。一般这个可以在你拥有了一定的刷题量的基础上进行，不必一开始就这样练习。另外，也可以在纸上练习，把纸想象成白板，也能达到很不错的效果，尤其对锻炼清晰的笔迹有很大的帮助。</p><p>为了避免遗忘，养成整理回顾的习惯。</p><p>刷题的时候，会出现一种情况，之前刷过的题目一下就忘记了。要克服这种情况的出现，我用下面的办法。</p><p>1. 周末的时候回顾一下这一周做过的题目，主要是整理思路。</p><p>2. 把这周里出现的难啃的题目单独拿出来，记录到难题笔记里，反复看。</p><p>3. 刷题的时候，尽量把思路理清，而不是记代码。</p><p>最后，一定要把自己刷过的题目和最好的解法写下来。</p><p>我会按照老师的说法，把刷过的题目和最好的解法写下来，写到我的<a href="https://github.com/ML-ZimingMeng/python-problems-and-solutions" target="_blank" rel="noopener">github</a>上，欢迎一起交流。</p><h2 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h2><p>简历就是你的门面，好的简历能让你在众多的求职者中脱颖而出。很多公司的职位都是很有限的，如果招聘人员能够快速准确地从你的简历里找出他们想要的东西，比如你的技术，经验，或者研究成果等，那么你就会有更大地机会进入到面试的环节，另外，最重要的一点，想一想你为了能面试这家公司，付出了那么多的心血去刷题，最后因为简历没能被看上而与机会失之交臂，那是多么多么的不应该啊！可以说，好的简历是打开面试机会的大门。</p><p>怎么样去写好一份简历呢？</p><p>一、要有针对性</p><p>你的简历必须要凸显出你才是适合这个职务的不二人选。</p><p>每个职务的招聘一般都会有一些基本的要求，比如某个职务要招的是前端网络工程师，要求有 5 年以上的工作经验，精通 JavaScript，HTML5，CSS3，熟悉 React 框架等，那么你的简历必须要想办法体现出你能满足上面的基本要求。</p><p>可以通过你的工作履历表来体现出你有 5 年以上的工作经验，通过罗列出与前端相关的技术名词作为你所拥有和掌握的技术来体现你适合这个岗位的技术需求。有些人既懂得 Java，SQL，也懂得 JavaScript，但是在简历当中却把 JavaScript 罗列在了后面，有时候会让人觉得 JavaScript 也许并不是你的强项，也许你更适合做后端的工程师。换句话说，你的简历必须要能投其所好。</p><p>二、写好工作履历</p><p>招聘人员会把大部分时间花在阅读你的工作履历上。对于一个要谋求软件工程师职务的人的简历，必须要做到以下几点。</p><p>1. 对于以往的每一份工作，都必须写明公司的名称，起始时间和终止时间。</p><p>2. 针对每份工作，言简意赅地罗列出自己做过的项目，以及你在项目中扮演的角色。</p><p>3. 最好能体现出每个项目最终的结果以及所带来的影响。</p><p>在罗列项目的时候，最好能写明，你在这个项目中扮演的角色是什么，采用了什么样架构，使用了什么编程语言，解决了什么问题，达到了什么效果或者产生了什么样的影响。</p><p>三、控制页数</p><p>大厂的招聘人员，一般都会在每天分配出固定的时间来审阅大量的简历，你的简历一般都是以电子版的形式存储在系统中，招聘人员通过关键字搜索来找出合适的简历，然后加以阅读。通常，你的简历最好不要超过两页，最好能控制在一页。</p><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>当你拿到面试通知的时候，离成功就差最后一步了，只需要你在面试中好好表现，发挥出你的水平。</p><p>面试不光是脑力活，同时也是体力活，如何让你的脑力和体力都能跟上高强度的大厂技术面试呢？一种比较行之有效的方法就是多拿一些中小型公司练手。</p><p>中小型公司有时候比较倾向于考察你的经验，这是一个锻炼你跟面试官交流经验的绝佳机会，更重要的是，通过这些练手，能让你更好地梳理自己的技术经验，总结出适合你自己的交谈风格，这样，当你在大厂里被问到工作经验相关的问题时，就能脱口而出，而且条理清晰，这些其实跟刷题一样，都是要通过不断地练习的。</p><p>另外，中小型公司也会考察算法题，但是难度一般来说不会特别难，这是一个检验你算法和数据结构知识水平以及能不能写出高质量代码的难得的训练机会。有些中小型公司的技术面试也是出了名的难，如果你在这些面试中失败了，这是好事，你要从中吸取教训，把答得不好的题反复思考一下，在哪里跌倒就在哪里爬起来。</p><p>总之，通过一些真刀真枪地实战，可以帮助你迅速地调整面试的状态，记住，你的最终目标是你心仪的公司，不要被中间的一两个失利的战斗影响到自己，找出问题所在，为下一个面试做好准备。</p><p>下面说一下现场面试，现场面试真正要考察的是下面几个方面。</p><p>1. 你的技术水平够不够硬。</p><p>也就是说，你能不能在 30 分钟之类写出一道简单的题目以及一道中等甚至更难的题目。如果你的知识点不够牢固，写题的速度不够快，是非常难过这关的。但是，只要你努力刷题，一定会有好的结果。</p><p>2. 你分析问题的能力。</p><p>当面试官给你出问题的时候，他最希望的，并不是看到你拿到题目立即写出答案，而是希望你能跟他交流，把你的想法说明白。就好比你和面试官是同事，你们在一起讨论问题一样，只不过他对这个问题早已有了自己的想法，他想听听你的意见，说不定你的方法更好。</p><p>3. 你将思想变为代码的能力。</p><p>如果你和面试官的交流过程中，能始终呈现出一种状态，迅速地将自己的思考转变为代码，然后清晰地写在白板上。就算你不能完美地写出一道题目的答案，我相信面试官也一定会满意的，因为这要比那些只能夸夸其谈而写不出代码的人要强太多。</p><p>4. 检查和分析代码的能力。</p><p>一般在你写出了代码后，面试官会让你举几种情况来考虑看看你的算法是否行得通。最好的做法就是你自己要主动地提出来，然后给出几个比较有代表性的测试输入，然后过一遍你的程序，分析出结果。最后，一定要去分析一下时间和空间复杂度。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>老话说，“书山有路勤为径，学海无涯苦作舟“，共勉！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 面试 </tag>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
